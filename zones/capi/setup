#!/usr/bin/bash

# This script runs with the $CONFIG_assets_ip variable set to the assets zone
# IP address.  Its up to this script to pull down the rest of the files it
# needs from the assets zone and setup the zone for the given role.  This
# script is run in the background by the mdata svc so its ok if it takes
# a little while to install all of the pkgs.

PATH=/opt/local/bin:/opt/local/sbin:/usr/bin:/usr/sbin

role=capi
app_name=$role

# symlink_ruby() just creates missing symlinks to ruby18 and irb18 on zones
# running ruby applications.
# It does not expect any argument.
#
function symlink_ruby
{
  # These happen to do not be created always:
  if [[ ! -e /opt/local/bin/ruby ]]; then
    echo "Symlinking ruby"
    ln -s /opt/local/bin/ruby18 /opt/local/bin/ruby
  fi

  if [[ ! -e /opt/local/bin/irb ]]; then
    echo "Symlinking irb"
    ln -s /opt/local/bin/irb18 /opt/local/bin/irb
  fi
}

#
# It's pretty obvious what create_jill_account() does. Intended to run on zones
# running ruby applications. It does not expect any arguments, for now.
#
function create_jill_account
{
  echo "Creating jill account"
  groupadd jill
  useradd -g jill -d /opt/smartdc jill
  chown -R jill:jill /opt/smartdc

  # XXX /etc/oshadow breaks changepass, not sure yet what's putting it there.
  if [[ -f /etc/oshadow ]]; then
      echo "WARNING: removing /etc/oshadow"
      rm -f /etc/oshadow
  fi

  echo "jill:naiWaic8sh" | /opt/local/sbin/changepass -n -m
  usermod -P 'Service Management' jill
  usermod -s /usr/bin/bash jill
  # Properly set PATH and other relevant stuff.
  cp /home/admin/.bash_profile /opt/smartdc/.bash_profile
  cp /home/admin/.bashrc /opt/smartdc/.bashrc
  cp /home/admin/.irbrc /opt/smartdc/.irbrc
  cp /home/admin/.profile /opt/smartdc/.profile
}

cd /var/svc

curl -k -o zoneconfig -s $CONFIG_assets_ip:/extra/$role/zoneconfig
curl -k -o hn_config -s $CONFIG_assets_ip:/extra/$role/hn_config
curl -k -o hn_generic -s $CONFIG_assets_ip:/extra/$role/hn_generic

# Cookie to identify this as a SmartDC zone and its role
mkdir -p /var/smartdc/capi

# We need some of the headnode config, but don't leave the files around
. /var/svc/hn_config
. /var/svc/hn_generic
rm -f /var/svc/hn_config /var/svc/hn_generic
# Load up the config values
. /var/svc/zoneconfig

# The user-script is downloaded and executed on every zone boot. We take
# advantage of this to maintain the cached config values post-setup.
if [ -e /var/svc/setup_complete ]; then
	echo "Updating CAPI configuration"
	rm -f /opt/smartdc/capi/config/config.yml

	cd /opt/smartdc/capi && \
	MAIL_TO="${MAIL_TO}" \
	MAIL_FROM="${MAIL_FROM}" \
	CAPI_HTTP_ADMIN_USER="${CAPI_HTTP_ADMIN_USER}" \
	CAPI_HTTP_ADMIN_PW="${CAPI_HTTP_ADMIN_PW}" \
	/opt/local/bin/rake install:config -f /opt/smartdc/capi/Rakefile && \
	sleep 1 && \
	chown jill:jill /opt/smartdc/capi/config/config.yml
	svcadm restart capi
	exit 0
fi

# Setup the zone
curl -k -o pkgsrc -s $CONFIG_assets_ip:/extra/$role/pkgsrc_2010q4
curl -k -o fs.tar.bz2 -s $CONFIG_assets_ip:/extra/$role/fs.tar.bz2
curl -k -o pkgsrc.tar -s $CONFIG_assets_ip:/extra/pkgsrc/pkgsrc_2010q4.tar

mkdir -p /opt/smartdc/capi
mkdir -p /opt/smartdc/capi-data

# Unpack fs.tar and copy files into proper locations within the zone
mkdir /.stage
echo "unpack fs.tar"
(cd /.stage; bzcat /var/svc/fs.tar.bz2 | tar xbf 512 -)
rm -f /var/svc/fs.tar.bz2
echo "install root"
(cd /.stage/root; tar cbf 512 - *) | (cd /; tar xbf 512 -)
echo "install site"
(cd /.stage/site; tar cbf 512 - *) | (cd /lib/svc/manifest/site; tar xbf 512 -)
rm -rf /.stage

# Install using local pkg repo
mkdir -p /var/svc/pkgs
(cd /var/svc/pkgs && tar -xf /var/svc/pkgsrc.tar \
      $(cat /var/svc/pkgsrc | sed -e "s/$/.tgz/" | xargs))
rm -f /var/svc/pkgsrc.tar

for i in `cat /var/svc/pkgsrc`
do
	echo "Installing $i" 
	pkg_info $i >/dev/null 2>&1 || pkg_add -f /var/svc/pkgs/$i
done
rm -rf /var/svc/pkgs

echo "configuring $ZONENAME zone datasets"

app='capi'
# This needs to run after scmgit pkgsrc package has been installed:

# Get git revision:
cd /opt/smartdc/$app-repo
REVISION=$(/opt/local/bin/git rev-parse --verify HEAD)
# Export complete repo into $app:
cd /opt/smartdc/$app-repo

/opt/local/bin/git checkout-index -f -a --prefix=/opt/smartdc/$app/

# Export only config into $app-data:
cd /opt/smartdc/$app-repo
# Create some directories into $app-data
mkdir -p /opt/smartdc/$app-data/log
mkdir -p /opt/smartdc/$app-data/tmp/pids

# Remove and symlink directories:
if [[ ! -n ${KEEP_DATA_DATASET} ]]; then
  mv /opt/smartdc/$app/config /opt/smartdc/$app-data/config
else
  rm -Rf /opt/smartdc/$app/config
fi

rm -Rf /opt/smartdc/$app/log
rm -Rf /opt/smartdc/$app/tmp
rm -Rf /opt/smartdc/$app/config
ln -s /opt/smartdc/$app-data/log /opt/smartdc/$app/log
ln -s /opt/smartdc/$app-data/tmp /opt/smartdc/$app/tmp
ln -s /opt/smartdc/$app-data/config /opt/smartdc/$app/config

# Save REVISION:
if [[ ! -n ${KEEP_DATA_DATASET} ]]; then
  echo "${REVISION}">/opt/smartdc/$app-data/REVISION
fi
echo "${REVISION}">/opt/smartdc/$app/REVISION

# Save VERSION (Updates based on this):
APP_VERSION=$(/opt/local/bin/git describe --tags)
if [[ ! -n ${KEEP_DATA_DATASET} ]]; then
  echo "${APP_VERSION}">/opt/smartdc/$app-data/VERSION
fi
echo "${APP_VERSION}">/opt/smartdc/$app/VERSION

# Cleanup build products:
cd /root/
rm -Rf /opt/smartdc/$app-repo
rm /root/$app-app-timestamp

symlink_ruby
create_jill_account

# enable slow query logging (anything beyond 200ms right now)
echo "log_min_duration_statement = 200" >> /var/pgsql/data90/postgresql.conf

# Import postgres manifest straight from the pkgsrc file:
if [[ -z $(/usr/bin/svcs -a|grep postgresql) ]]; then
  echo "Importing posgtresql service"
  /usr/sbin/svccfg import /opt/local/share/smf/manifest/postgresql:pg90.xml
  sleep 10 # XXX
  #/usr/sbin/svccfg -s svc:/network/postgresql:pg90 refresh
  /usr/sbin/svcadm enable -s postgresql
else
  echo "Restarting postgresql service"
  /usr/sbin/svcadm disable -s postgresql
  /usr/sbin/svcadm enable -s postgresql
  sleep 2
fi

# CAPI specific

# Note these files should have been created by previous Rake task.
# If we copy these files post "gsed", everything is reset:
if [[ ! -e /opt/smartdc/capi/config/config.ru ]]; then
  cp /opt/smartdc/capi/config/config.ru.sample /opt/smartdc/capi/config/config.ru
fi

if [[ ! -e /opt/smartdc/capi/config/config.yml ]]; then
   cd /opt/smartdc/capi && \
   MAIL_TO="${MAIL_TO}" \
   MAIL_FROM="${MAIL_FROM}" \
   CAPI_HTTP_ADMIN_USER="${CAPI_HTTP_ADMIN_USER}" \
   CAPI_HTTP_ADMIN_PW="${CAPI_HTTP_ADMIN_PW}" \
   /opt/local/bin/rake install:config -f /opt/smartdc/capi/Rakefile && \
   sleep 1 && \
   chown jill:jill /opt/smartdc/capi/config/config.yml
fi

if [[ ! -e /opt/smartdc/capi/gems/gems ]] || [[ $(ls /opt/smartdc/capi/gems/gems| wc -l) -eq 0 ]]; then
  echo "Unpacking frozen gems for Customers API."
  (cd /opt/smartdc/capi; PATH=/opt/local/bin:$PATH /opt/local/bin/rake gems:deploy -f /opt/smartdc/capi/Rakefile)
fi

if [[ ! -e /opt/smartdc/capi/config/unicorn.smf ]]; then
  echo "Creating Customers API Unicorn Manifest."
  /opt/local/bin/ruby -rerb -e "user='jill';group='jill';app_environment='production';application='capi'; working_directory='/opt/smartdc/capi'; puts ERB.new(File.read('/opt/smartdc/capi/smartdc/unicorn.smf.erb')).result" > /opt/smartdc/capi/config/unicorn.smf
  chown jill:jill /opt/smartdc/capi/config/unicorn.smf
fi

if [[ ! -e /opt/smartdc/capi/config/unicorn.conf ]]; then
  echo "Creating Customers API Unicorn Configuration file."
  /opt/local/bin/ruby -rerb -e "app_port='8080'; worker_processes=$WORKERS; working_directory='/opt/smartdc/capi'; application='capi'; puts ERB.new(File.read('/opt/smartdc/capi/smartdc/unicorn.conf.erb')).result" > /opt/smartdc/capi/config/unicorn.conf
  chown jill:jill /opt/smartdc/capi/config/unicorn.conf
fi

echo "Configuring Customers API Database."
cat > /opt/smartdc/capi/config/database.yml <<CAPI_DB
:development: &defaults
  :adapter: postgres
  :database: capi
  :host: $POSTGRES_HOST
  :username: $POSTGRES_USER
  :password: $POSTGRES_PW
  :encoding: UTF-8
:test:
  <<: *defaults
  :database: capi_test
:production:
  <<: *defaults
  :database: capi

CAPI_DB

if [[ ! -e /opt/smartdc/capi/tmp/pids ]]; then
  su - jill -c "mkdir -p /opt/smartdc/capi/tmp/pids"
fi


# Just in case, create /var/logadm
if [[ ! -d /var/logadm ]]; then
  mkdir -p /var/logadm
fi

# Log rotation:
cat >> /etc/logadm.conf <<LOGADM
capi -C 100 -c -s 10m /opt/smartdc/capi/log/*.log
postgresql -C 5 -c -s 100m /var/log/postgresql90.log
LOGADM

set -o xtrace

PGPASSFILE=/opt/smartdc/.pgpass

# This is a workaround.  Normally we would want a proper SMF dependency on the
# postgresql svc, but its too late in the release cycle so we're going to
# hardcode a loop to check the state of the svc here.  We should fix this
# later.
for i in 0 1 2 3 4 5 6 7 8 9
do
    svc=$(/usr/bin/svcs -H network/postgresql)
    state=${svc%% * *}
    [ "$state" == "online" ] && break
    sleep 5
done
# No matter what the state now, we move on.

# Postgres starts out with the default pw of 'postgres'.  We need to change
# it to POSTGRES_PW before we can do anything else.
export PGPASSWORD=postgres
if ! /opt/local/bin/psql -U postgres \
    -c "ALTER USER postgres WITH PASSWORD '$POSTGRES_PW';" template1 ; then
    # We failed to change the pw.  This might happen if we already changed it
    # but the method failed later and we are re-running.  Since we are running
    # with errexit, we need to handle a failure, but we assume the pw is
    # already updated and just note this.
    echo "Changing the default password failed"
fi
export -n PGPASSWORD

# Given PostgreSQL will be into a separated zone, we cannot rely into SMF
# to test DB availability. Need to ping the DB and proceed once we've
# verified we can stablish a connection:

RETRY_AFTER=$DBCONN_RETRY_AFTER NUM_ATTEMPTS=$DBCONN_NUM_ATTEMPTS RACK_ENV=production /opt/local/bin/ruby /opt/smartdc/capi/script/psql-test-connect.rb

if [[ $? -ne 0 ]]; then
  echo "PostgreSQL not available after ${DBCONN_NUM_ATTEMPTS}, aborting."
  exit 1
else
  echo "Verified PostgreSQL availability, moving forward."
fi

# Without this, mapi db existence checking will always fail:
echo "$POSTGRES_HOST:*:*:$POSTGRES_USER:$POSTGRES_PW" >> /root/.pgpass
chmod 0600 /root/.pgpass

if [[ -z $(/opt/local/bin/psql -U postgres -h $POSTGRES_HOST -c "\\l"|grep capi) ]]; then
  echo "Creating capi database"
  echo "$POSTGRES_HOST:*:*:$POSTGRES_USER:$POSTGRES_PW" >> /opt/smartdc/.pgpass
  chown jill /opt/smartdc/.pgpass
  chmod 0600 /opt/smartdc/.pgpass
  su - jill -c "/opt/local/bin/createdb -U postgres -h $POSTGRES_HOST capi"
fi

echo "Auto Upgrading Customers API Database."
su - jill -c "cd /opt/smartdc/capi; RACK_ENV=production SINATRA_ENV=production /opt/local/bin/rake db:autoupgrade -f /opt/smartdc/capi/Rakefile"
sleep 1


if [[ -z $(/usr/bin/svcs -a|grep capi|grep -v capi-update|grep -v capi-setup|grep -v capi_ipf_setup) ]]; then
  echo "Importing Customers API Unicorn Manifest"
  /usr/sbin/svccfg import /opt/smartdc/capi/config/unicorn.smf
  #/usr/sbin/svccfg -s svc:/network/smartdc/application/capi:default refresh
fi

echo Importing sdc-ipf-setup.xml
/usr/sbin/svccfg import /lib/svc/manifest/site/sdc-ipf-setup.xml

echo Enabling service sdc-ipf-setup
/usr/sbin/svcadm enable smartdc/capi_ipf_setup

echo "Calling CAPI Admin User creation task."
su - jill -c "cd /opt/smartdc/capi; RACK_ENV=production SINATRA_ENV=production \
  ADMIN_UUID="${CAPI_ADMIN_UUID}" \
  ADMIN_PW="${CAPI_ADMIN_PW}" \
  ADMIN_LOGIN="${CAPI_ADMIN_LOGIN}" \
  ADMIN_EMAIL="${CAPI_ADMIN_EMAIL}" \
  /opt/local/bin/rake install:capi_admin -f /opt/smartdc/capi/Rakefile"
sleep 1

echo "Writing customer.url file to /root/customer.url"
echo "/customers/${CAPI_ADMIN_UUID}/zones" > /root/customer.url

if [[ -f $(svcprop -p 'capi/allowed_file' svc:/platform/smartdc/capi_ipf_setup) ]]; then
    svcadm enable svc:/network/ipfilter:default
fi

# Ensure everything in /opt/smartdc is owned by jill
chown -R jill:jill /opt/smartdc

# fix perms on /home
chown root:root /home
chmod 0555 /home

touch /var/svc/setup_complete
echo "setup done"
