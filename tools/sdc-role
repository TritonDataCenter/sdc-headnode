#!/usr/bin/bash
#

# Important! This is just a place-holder until we rewrite in node.
#

if [ "$TRACE" != "" ]; then
    export PS4='${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
    set -o xtrace
fi

if [[ ! -f /opt/smartdc/bin/libdc.sh ]]; then
    echo "fatal: unable to find libdc.sh"
    exit 1
fi
source /opt/smartdc/bin/libdc.sh

command=$1
shift

usage()
{
    cat <<EOF

Usage:
        $0 <sub-command> [options]

Sub-commands:

        create [role]   - create a sdc_role zone
        destroy [alias] - destroy an sdc_role zone by alias
        list            - list all sdc_role zones in this DC

EOF
    exit 1
}

add_config_ips()
{
    role=$1
    admin_ip=$2
    external_ip=$3

    /usbkey/scripts/mount-usb.sh >/dev/null 2>&1
    [[ $? != 0 ]] && fatal "unable to mount the USB key"

    for net in admin external; do
        this_ip=$( eval echo \${$(echo ${net}_ip)} )
        if [[ -n ${this_ip} ]]; then
            existing_ips=$(grep "^${role}_${net}_ips=" /mnt/usbkey/config \
                | cut -d'=' -f2 | tr -d ' ' | tr ',' ' ')
            new_ips=$( (for ip in ${existing_ips}; do echo ${ip}; done; \
                echo ${this_ip}) | sort | uniq | xargs | tr ' ' ',')
            if [[ -z ${existing_ips} ]]; then
                # remove the empty key if it exists
                grep -v "^${role}_${net}_ips=" /mnt/usbkey/config \
                    > /mnt/usbkey/config.new
                echo "${role}_${net}_ips=${new_ips}" >> /mnt/usbkey/config.new
                mv /mnt/usbkey/config.new /mnt/usbkey/config
            elif [[ $(echo "${existing_ips}" | wc -c) \
                -lt $(echo "${new_ips}" | wc -c) ]]; then

                # new list is longer
                sed -i "" -e \
                    "s/^${role}_${net}_ips=.*$/${role}_${net}_ips=${new_ips}/" \
                    /mnt/usbkey/config
            fi
        fi
    done

    # if the zone has its own additional update_config script, call that now
    # it can update the /mnt/usbkey/config if it needs to, and any other
    # config options
    if [[ -x /usbkey/zones/${role}/update_config ]]; then
        /usbkey/zones/${role}/update_config
    fi

    cmp /mnt/usbkey/config /usbkey/config >/dev/null 2>&1 \
        || cp /mnt/usbkey/config /usbkey/config
    umount /mnt/usbkey

    # update zoneconfig for any zone that has these keys
    for z in $(ls -1 /usbkey/zones); do
        if [[ -f /usbkey/zones/${z}/zoneconfig ]]; then
            grep "=.*${role}_.*_ips" /usbkey/zones/${z}/zoneconfig \
                >/dev/null 2>&1 \
                && update_zoneconfig ${z}
        fi
    done
}

del_config_ips()
{
    role=$1
    zone_ips=$2

    /usbkey/scripts/mount-usb.sh >/dev/null 2>&1
    [[ $? != 0 ]] && fatal "unable to mount the USB key"

    admin_ips=$(grep "^${role}_admin_ips=" /mnt/usbkey/config)
    external_ips=$(grep "^${role}_external_ips=" /mnt/usbkey/config)
    new_admin=${admin_ips}
    new_external=${external_ips}

    for ip in ${zone_ips}; do
        new_admin=$(echo "${new_admin}" \
            | sed -e "s/\([=,]\)${ip},/\1/" \
            | sed -e "s/\([=,]\)${ip}$/\1/" \
            | sed -e "s/,$//")
        new_external=$(echo "${new_external}" \
            | sed -e "s/\([=,]\)${ip},/\1/" \
            | sed -e "s/\([=,]\)${ip}$/\1/" \
            | sed -e "s/,$//")
    done

    sed -e "s/^${role}_admin_ips=.*$/${new_admin}/" /mnt/usbkey/config \
        | sed -e "s/^${role}_external_ips=.*$/${new_external}/" \
        > /mnt/usbkey/config.new

    if ! cmp /mnt/usbkey/config.new /mnt/usbkey/config >/dev/null 2>&1; then
        mv /mnt/usbkey/config.new /mnt/usbkey/config
    else
        rm -f /mnt/usbkey/config.new
    fi

    # if the zone has its own additional update_config script, call that now
    # it can update the /mnt/usbkey/config if it needs to, and any other
    # config options
    if [[ -x /usbkey/zones/${role}/update_config ]]; then
        /usbkey/zones/${role}/update_config
    fi

    if ! cmp /mnt/usbkey/config /usbkey/config >/dev/null 2>&1; then
        cp /mnt/usbkey/config /usbkey/config
    fi

    umount /mnt/usbkey

    # update zoneconfig for any zone that has these keys
    for z in $(ls -1 /usbkey/zones); do
        if [[ -f /usbkey/zones/${z}/zoneconfig ]]; then
            grep "=.*${role}_.*_ips" /usbkey/zones/${z}/zoneconfig \
                >/dev/null 2>&1 \
                && update_zoneconfig ${z}
        fi
    done
}

next_alias()
{
    local zrole=$1
    local zone=
    local idx=0

    local all_zones=$(vmapi "/vms?owner_uuid=${CONFIG_ufds_admin_uuid}&state=active" \
        | json -H -e 'alias=(alias || "-")' -e 'smartdc_role=(tags.smartdc_role || "-")' \
        -a smartdc_role alias | tr ' ' ',')

    # 100 here for runaway protection
    while [[ ${idx} -lt 100 ]]; do
        local found=0
        for zone in ${all_zones}; do
            local role=${zone%%,*}
            local alias=${zone##*,}

            if [[ ${role} == ${zrole} && ${alias} == "${zrole}${idx}" ]]; then
                found=1
            fi
        done

        # if it wasn't found, we'll use this one
        [[ ${found} == 0 ]] && break

        idx=$((${idx} + 1))
    done

    [[ ${idx} == 100 ]] && fatal "next_alias(${zrole}): alias overflow"

    echo "${zrole}${idx}"
}

add_pkg_zone_parameters()
{
    zrole=$1

    local package=$(eval "echo \${CONFIG_${zrole}_pkg}")
    if [[ -z ${package} ]]; then
        fatal "${zrole}: unable to determine package."
    fi

    local pkg=
    local idx=0
    while [[ -n $(eval "echo \${CONFIG_pkg_${idx}}") ]]; do
        pkg=$(eval "echo \${CONFIG_pkg_${idx}}")
        if [[ ${pkg%%:*} == ${package} ]]; then
            # name:ram:swap:disk:cap:nlwp:iopri
            local ram=$(echo ${pkg} | cut -d ':' -f 2)
            local swap=$(echo ${pkg} | cut -d ':' -f 3)
            local disk=$(echo ${pkg} | cut -d ':' -f 4)
            local cap=$(echo ${pkg} | cut -d ':' -f 5)
            local nlwp=$(echo ${pkg} | cut -d ':' -f 6)
            local iopri=$(echo ${pkg} | cut -d ':' -f 7)

            [[ -n ${ram} ]] \
                && zone_parameters="${zone_parameters}, ram: ${ram}"
            [[ -n ${swap} ]] \
                && zone_parameters="${zone_parameters}, max_swap: ${swap}"
            [[ -n ${disk} ]] \
                && zone_parameters="${zone_parameters}, quota: ${disk}"
            [[ -n ${cap} ]] \
                && zone_parameters="${zone_parameters}, cpu_cap: ${cap}"
            [[ -n ${nlwp} ]] \
                && zone_parameters="${zone_parameters}, max_lwps: ${nlwp}"
            [[ -n ${iopri} ]] \
                && zone_parameters="${zone_parameters}, zfs_io_priority: ${iopri}"
        fi
        idx=$((${idx} + 1))
    done
}

check_zone_dependencies()
{
    local zrole=$1
    local setup_json="/usbkey/zones/${zrole}/setup.json"

    if [[ ! -f ${setup_json} ]]; then
        fatal \
            "${zrole}: missing setup.json file in /usbkey/config/zones/${zrole}"
    fi

    local found=
    local installed_roles=$(vmapi \
        "/vms?owner_uuid=${CONFIG_ufds_admin_uuid}&state=active" \
        | json -H -e 'smartdc_role=(tags.smartdc_role || "-")' \
        -a smartdc_role | tr ' ' ',')

    for dep in $(json -a dependencies < ${setup_json} | json -a); do
        found=0
        for installed in ${installed_roles}; do
            if [[ ${installed} == ${dep} ]]; then
                found=1
            fi
        done

        if [[ ${found} == 0 ]]; then
            echo "FATAL: You must have at least one ${dep} zone installed" \
                "before installing ${zrole}."
            return 1
        fi
    done

    return 0
}

get_zone_parameters()
{
    local zrole=$1
    local setup_json="/usbkey/zones/${zrole}/setup.json"

    if [[ ! -f ${setup_json} ]]; then
        fatal \
            "${zrole}: missing setup.json file in /usbkey/config/zones/${zrole}"
    fi

    # This is where results go!
    if [[ $(json brand < ${setup_json}) == "joyent-minimal" ]]; then
        zone_parameters="{ brand: 'joyent-minimal'"
    else
        zone_parameters="{ brand: 'joyent'"
    fi

    local dataset=$(cat /usbkey/zones/${zrole}/dataset | head -1)
    if [[ -z ${dataset} || ! -f /usbkey/datasets/${dataset}.dsmanifest ]]; then
        fatal "${zrole}: has missing/invalid dataset version."
    fi
    dataset=$(json uuid < /usbkey/datasets/${dataset}.dsmanifest)
    if [[ -z ${dataset} ]]; then
        fatal "${zrole}: unable to find dataset uuid."
    fi
    zone_parameters="${zone_parameters}, dataset_uuid: '${dataset}'"
    zone_parameters="${zone_parameters}, owner_uuid: '${CONFIG_ufds_admin_uuid}'"

    local primary_network=$(json primary_network < ${setup_json})
    local all_networks=$(napi /networks | json -H -a name uuid | tr ' ' ',')
    local networks=$( (json networks | json -a) < ${setup_json} | xargs)
    local primary_uuid=
    local net_uuids=
    local all_net=
    local net=

    for net in ${networks}; do
        for all_net in ${all_networks}; do
            if [[ ${all_net%%,*} == ${net} ]]; then
                if [[ -z ${net_uuids} ]]; then
                    net_uuids="\"${all_net##*,}\""
                else
                    net_uuids="${net_uuids},\"${all_net##*,}\""
                fi
            fi
            if [[ ! -z {$primary_network} \
                && ${all_net%%,*} == ${primary_network} ]]; then

                primary_uuid=${all_net##*,}
            fi
        done
    done

    zone_parameters="${zone_parameters}, networks: [${net_uuids}]"

    if [[ -n ${primary_uuid} ]]; then
        zone_parameters="${zone_parameters}, primary_network: '${primary_uuid}'"
    fi

    # check for delegated dataset
    if [[ $(json delegate_dataset < ${setup_json}) == "true" ]]; then
        zone_parameters="${zone_parameters}, delegate_dataset: true"
    fi

    # find the next alias
    zone_parameters="${zone_parameters}, alias: '$(next_alias ${zrole})'"

    # add suff that comes from the pkg
    add_pkg_zone_parameters ${zrole}
}

setup_zone_files()
{
    zrole=$1

    local extra_root=/usbkey/extra
    local assetdir=${extra_root}/${zrole}
    local srcdir=/usbkey/zones/${zrole}

    mkdir -p ${assetdir}
    for file in backup bashrc configure fs.tar.bz2 pkgsrc restore setup; do
        if [[ -f ${srcdir}/${file} ]]; then
            rm -f ${assetdir}/${file}
            ln ${srcdir}/${file} ${assetdir}/${file}
        fi
    done
    for file in $(ls /usbkey/default/*.common); do
        rm -f ${assetdir}/$(basename ${file})
        ln /usbkey/default/$(basename ${file}) ${assetdir}/$(basename ${file})
    done
}

update_zoneconfig()
{
    zrole=$1

    in_filename=/usbkey/zones/${zrole}/zoneconfig
    out_filename=/usbkey/extra/${zrole}/zoneconfig

    if [[ ! -f ${in_filename} ]]; then
        fatal "FATAL: ${in_filename} does not exist."
    fi

    mkdir -p /usbkey/extra/${zrole}

    # (re)create the zoneconfig file
    (
        . /usbkey/config
        . /usbkey/config.inc/generic
        . ${in_filename}
        for var in $(cat ${in_filename} \
        | grep -v "^ *#" | grep "=" | cut -d'=' -f1); do
        echo "${var}='${!var}'"
        done
    ) > ${out_filename}
}

sdc_create()
{
    local zrole=$1
    local networks=

    if [[ -z ${zrole} ]]; then
        usage
    fi

    zone_parameters=
    check_zone_dependencies ${zrole}
    if [[ $? != 0 ]]; then
        exit 1
    fi
    get_zone_parameters ${zrole}
    setup_zone_files ${zrole}

    # update config that zone uses, before provision in case something changed.
    update_zoneconfig "${zrole}"

    # above we added: { ..., so now we need to close the curlies.
    zone_parameters="${zone_parameters} }"

    local smartdc_type=
    local create_json="/usbkey/zones/${zrole}/create.json"
    if [[ -f ${create_json} ]]; then
        smartdc_type=$(json tags.smartdc_type < ${create_json})
    fi
    if [[ -z ${smartdc_type} ]]; then
        smartdc_type="extra"
    fi

    # create mdata temp file
    tmpfile="/tmp/payload.$$"
    node -e "
        fs = require('fs');
        us = fs.readFileSync('/usbkey/default/user-script.common', 'utf-8');
        o = ${zone_parameters};
        o.tags = {};
        o.tags['smartdc_role'] = '${zrole}';
        o.tags['smartdc_type'] = '${smartdc_type}';
        o.customer_metadata = {};
        o.customer_metadata['assets-ip'] = '${CONFIG_assets_admin_ip}';
        o.customer_metadata['user-script'] = us.toString();
        fs.writeFileSync('${tmpfile}', JSON.stringify(o, null, 2), 'utf-8');" \
        2>&1

    if [[ $? != 0 || ! -f ${tmpfile} ]]; then
        echo "Unable to convert user script to JSON." >&2
        exit 1
    fi

    provision_zone_from_payload ${tmpfile}
    if [[ $? == 0 ]]; then
        # created successfully
        local admin=
        local external=
        local result=$(napi /nics?belongs_to_uuid=${provisioned_uuid} | json -H -a nic_tag ip | tr ' ' '=')
        eval "${result}"
        # portal is the only special case where we have no admin IP
        if [[ -z ${admin} && ${zrole} != "portal" ]]; then
            fatal "unable to find Admin IP for ${provisioned_uuid}"
        fi
        add_config_ips "${zrole}" "${admin}" "${external}"
    fi
}

sdc_destroy()
{
    local arg=$1

    local zone=
    local destroy_uuid=
    for zone in $(vmapi "/vms?owner_uuid=${CONFIG_ufds_admin_uuid}&state=active" \
        | json -H -e 'alias=(alias || "-")' \
        -e 'smartdc_role=(tags.smartdc_role || "-")' \
        -e 'smartdc_type=(tags.smartdc_type || "-")' \
        -a uuid smartdc_role smartdc_type alias | tr ' ' ','); do

        local uuid=${zone%%,*}
        local zrole=$(echo "${zone}" | cut -d ',' -f2)
        local ztype=$(echo "${zone}" | cut -d ',' -f3)
        local alias=${zone##*,}

        if [[ -z ${zrole} || ${zrole} == "-" ]]; then
            echo "sdc_destroy: zone '${arg}' has no smartdc_role." >&2
            continue
        fi

        if [[ -z $(eval echo \${${zrole}_count}) ]]; then
            eval ${zrole}_count=1
        else
            eval ${zrole}_count=$(($(eval echo \${${zrole}_count}) + 1))
        fi

        if [[ ${uuid} == ${arg} || ${alias} == ${arg} ]]; then
            [[ -n ${destroy_uuid} ]] && fatal "More than one zone found matching: '${arg}'"
            destroy_uuid=${uuid}
            destroy_zrole=${zrole}
            destroy_ztype=${ztype}
        fi
    done

    [[ -z ${destroy_uuid} ]] && fatal "sdc_destroy: unable to find uuid for zone matching '${arg}'"

    if [[ $(eval echo \${${destroy_zrole}_count}) -le 1 && ${destroy_ztype} == "core" ]]; then
        fatal "Cannot remove last ${destroy_zrole} zone (this is a core zone)."
    fi

    # Find the IPs that NAPI thinks the zone has so we can remove them
    local zone_ips=$(napi /nics?belongs_to_uuid=${destroy_uuid} | json -H -a ip | xargs)

    vmapi /vms/${destroy_uuid} -X DELETE > /tmp/destroy.$$ 2>&1

    echo "+ Sent DELETE to VMAPI for ${destroy_uuid}"
    watch_job /tmp/destroy.$$

    if [[ $? == 0 ]]; then
        # it's destroyed! Go ahead and remove IPs now.
        del_config_ips "${destroy_zrole}" "${zone_ips}"
    fi
}

sdc_list()
{
    local zone=

    printf "%-12s %-16s %-36s  %-7s %10s %16s %15s\n" \
        "ALIAS" "SERVER" "UUID" "RAM" "STATE" "ROLE" "ADMIN_IP"

    # this sets the variables:
    #
    #  hostname_UUID=<hostname>
    #
    # with uuid's dashes changed to underscore to meet bash's variable name requirements.
    host_mappings=$(cnapi /servers \
        | json -H -e 'uuid=uuid.replace(/\-/g, "_");' -a uuid hostname \
        | tr ' ' '=' | sed -e "s/^\([0-9a-f].*$\)/local hostname_\\1/")
    if [[ -n ${host_mappings} ]]; then
       eval ${host_mappings}
    fi

    for zone in $(vmapi "/vms?owner_uuid=${CONFIG_ufds_admin_uuid}&state=active" \
        | json -H -e 'smartdc_role=(tags.smartdc_role || "-")' \
            -a alias smartdc_role state uuid ram server_uuid \
        | tr ' ' ',' | sort); do

        local alias=$(echo "${zone}" | cut -d',' -f1)
        local role=$(echo "${zone}" | cut -d',' -f2)
        local state=$(echo "${zone}" | cut -d',' -f3)
        local uuid=$(echo "${zone}" | cut -d',' -f4)
        local ram=$(echo "${zone}" | cut -d',' -f5)
        local server_uuid=$(echo "${zone}" | cut -d',' -f6)
        local server_name=$(eval echo \${hostname_$(echo ${server_uuid} | tr '-' '_')})
        local admin_ip=$(napi /nics?belongs_to_uuid=${uuid} | json -H -a nic_tag ip | grep "^admin" | cut -d ' ' -f2)
        [[ -z ${admin_ip} ]] && admin_ip="-"
        [[ -z ${server_name} ]] && server_name="-"

        printf "%-12s %-16s %-36s  %-7s %10s %16s %15s\n" \
            "${alias}" "${server_name}" "${uuid}" "${ram}" "${state}" "${role}" "${admin_ip}"
    done
}

if [[ -z ${command} ]]; then
    usage
fi

case ${command} in
create)
    sdc_create "$@"
    exit $?
;;
destroy|delete)
    sdc_destroy "$@"
    exit $?
;;
list)
    sdc_list "$@"
    exit $?
;;
*)
    echo "Unknown command: ${command}" >&2
    usage
;;
esac

exit 2
