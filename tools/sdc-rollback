#!/bin/bash
#
# Copyright (c) 2012, Joyent, Inc., All rights reserved.
#

PATH=/usr/bin:/usr/sbin:/image/usr/sbin:/opt/smartdc/bin:/smartdc/bin
export PATH

SS="zones/var zones/opt zones/usbkey zones/config"
SKIP="$SS zones zones/swap zones/dump zones/cores zones/pre-upgrade"

declare -A SKIP_DS=()

function fatal
{
    msg=$1

    echo "ERROR: ${msg}" >/dev/stderr
    exit 1
}

#
# rollback only runs on headnodes.
#
[[ `sysinfo | json '["Boot Parameters"].headnode'` != "true" ]] && \
    fatal "this command can only be run on the headnode"

for i in $SKIP
do
	SKIP_DS[$i]=1
done

# -F is a private option to disable the prompt - used when rolling back
# in the middle of a failed upgrade.
FORCE=0
while getopts "F" opt
do
	case "$opt" in
		F)	FORCE=1;;
		*)	fatal "invalid option";;
	esac
done
shift $(($OPTIND - 1))

exists=`zfs list -o name -H zones/pre-upgrade 2>/dev/null`
[ -z "$exists" ] && fatal "rollback is not possible: data does not exist"

dname=${0%/*}
[[ "$dname" == "/tmp" ]] && FORCE=1

if [[ $FORCE == 0 ]]; then
    echo "--------------------------------------------------------------"
    echo "Warning:"
    echo "This command will revert and reboot the system to the previous"
    echo "release. Any new data and new configuration will be lost."
    echo "--------------------------------------------------------------"
    echo -n "Enter 'y' to continue: "
    read val
    [[ "$val" != "y" ]] && exit 0
fi

if [ "$dname" != "/tmp" ]; then
    # move the cmd to /tmp and rerun it there since /tmp doesn't rollback
    cp $dname/sdc-rollback /tmp
    cp /var/usb_rollback/ds_orig /tmp
    cp /var/usb_rollback/files_orig /tmp
    cd /tmp
    /tmp/sdc-rollback $@
    exit 0
fi

# quiesce the system

echo
echo "halting zones"
for i in `zoneadm list`
do
    [ "$i" == "global" ] && continue
    zoneadm -z $i halt
done

echo "transitioning to single-user mode"
svcadm milestone single-user

# in an unknown state, so first try to clean up the USB key mount
umount /mnt/usbkey >/dev/null 2>&1

# Restore usbkey backup
/usbkey/scripts/mount-usb.sh
[ $? != 0 ] && fatal "unable to mount USB key"
echo "rolling back USB key"

BDISK=`mount -p | nawk '{
    if ($3 == "/mnt/usbkey") {
        split($1, a, ":")
        print a[1]
    }
}'`
if [ ! -b "$BDISK" ]; then
    umount /mnt/usbkey
    fatal "USB device \"$BDISK\" does not exist"
fi

(cd /mnt/usbkey; rm -rf `ls -a | \
    nawk '{if ($1 != "." && $1 != ".." && $1 != "boot") print $1}'`)
(cd /var/usb_rollback; \
    tar cbf 512 - `ls -a | \
    nawk '{if ($1 != "." && $1 != ".." && $1 != "boot" && $1 != "ds_orig" && \
        $1 != "files_orig") print $1}'`) | \
    (cd /mnt/usbkey; tar xbf 512 -)
if [ $? != 0 ]; then
    umount /mnt/usbkey
    fatal "restoring USB key"
fi
cp -p /var/usb_rollback/boot/grub/menu.lst /mnt/usbkey/boot/grub/menu.lst
umount /mnt/usbkey
 
cnt=0
while [[ $cnt -lt 36 ]]; do
    st=`svcs -H -o state multi-user`
    [ "$st" == "disabled" ] && break
    sleep 5
    cnt=$(($cnt + 1))
done

[[ $cnt -ge 36 ]] && echo "multi-user not disabled \($st\) after 3 minutes"

# Put the old zone datasets back where they belong

echo "rolling back datasets"

# Start by deleting all of the new top-level datasets
for i in `zfs list -o name -H`
do
    # only want to check the ones directly under zones
    levels=`echo $i | nawk '{cnt=gsub("/", "/"); print cnt}'`
    [ $levels -ne 1 ] && continue

    [ -n "${SKIP_DS[$i]}" ] && continue

    zfs destroy -Rf $i >/dev/null 2>&1
done

# recreate old-style GZ cores dataset
zfs destroy -r zones/cores
zfs create -o quota=10g -o mountpoint=/zones/global/cores \
    -o compression=gzip zones/cores

# Rollback the ones we snapshotted.
for d in $SS
do
	zfs rollback ${d}@rollback
	zfs destroy  ${d}@rollback
done

# Rename back the ones we originally renamed.
LIST=`zfs list -o name -H | grep pre-upgrade`

# Do the following work in two separate loops so that the rename doesn't screw
# up setting the canmount property on sub-datasets.
for i in $LIST
do
	[ -n "${SKIP_DS[$i]}" ] && continue
	zfs set canmount=on $i
done

for i in $LIST
do
	[ -n "${SKIP_DS[$i]}" ] && continue

	# only need to rename the top-level
	levels=`echo $i | nawk '{cnt=gsub("/", "/"); print cnt}'`
	[ $levels -ne 2 ] && continue

	bname=${i##*/}
	zfs rename zones/pre-upgrade/$bname zones/$bname
done

zfs destroy zones/pre-upgrade

rm -rf /var/usb_rollback

echo "rolling back manifests"
(cd /zones/manifests; rm -rf *)
(cd /zones/manifests; cpio -idm </tmp/files_orig)
 
# If rolling back in the middle of a failed upgrade, grab the log files now
# that the file systems have been rolled back.
if [[ -d /var/upgrade_in_progress ]]; then
    rm -rf /var/upgrade_failed
    mv /var/upgrade_in_progress /var/upgrade_failed
    logs=`ls /tmp/*log* 2>/dev/null`
    [ -n "$logs" ] && cp -p /tmp/*log* /var/upgrade_failed
fi

echo "rebooting"
reboot
sleep 120
