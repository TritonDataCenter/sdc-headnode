#!/bin/bash
#
# Copyright (c) 2013, Joyent, Inc., All rights reserved.
#

PATH=/usr/bin:/usr/sbin:/image/usr/sbin:/opt/smartdc/bin:/smartdc/bin
export PATH

. /lib/sdc/config.sh

function fatal
{
    msg=$1

    echo "ERROR: ${msg}" >/dev/stderr
    exit 1
}

function upgrade_agents
{
    cp $ROOT/agents65.sh $assetdir

    local cnt=`sdc-oneachnode $OEN_ARGS "cd /var/tmp;
       [ -d /opt/smartdc/agents/lib ] && exit 0;
       curl -kOs $CONFIG_assets_admin_ip:/extra/agents65/agents65.sh && \
       bash /var/tmp/agents65.sh </dev/null \
           >/var/tmp/agent65_install.log 2>&1 && \
       echo 'SDC6 agent upgrade'" | egrep "SDC6 agent upgrade" | wc -l`
    echo "Installed $nm agent on $cnt node"
}

#
# post-upgrade only runs on headnodes.
#
[[ `sysinfo | json '["Boot Parameters"].headnode'` != "true" ]] && \
    fatal "this command can only be run on the headnode"

UPDATE_CN=""
COMMIT=0
WRITABLE=0
REPL_STAT=0
while getopts "cru:w" opt
do
	case "$opt" in
		c)	COMMIT=1;;
		r)	REPL_STAT=1;;
		u)	UPDATE_CN="$OPTARG";;
		w)	WRITABLE=1;;
		*)	fatal "invalid option";;
	esac
done

if [[ $WRITABLE == 1 ]]; then
    zonename=`vmadm list -H -o uuid,tags.smartdc_role | \
        nawk '/cloudapi/{print $1}'`

    [[ -z "$zonename" ]] && fatal "no CloudAPI zone"

    echo "Enabling read-write mode in CloudAPI"

    service_uuid=$(sdc-sapi /services?name=cloudapi | json -Ha uuid)
    [[ $? -ne 0 ]] && fatal "failed to get CloudAPI SAPI service"

    tmpfile=/tmp/cloudapi_metadata_changes.$$.json

    echo "{
        \"metadata\": {
            \"CLOUDAPI_READONLY\": false
         }
    }" > ${tmpfile}

    sdc-sapi /services/${service_uuid} -T ${tmpfile} >/dev/null 2>&1
    [[ $? != 0 ]] && fatal "Error updating CloudAPI metadata"
    rm ${tmpfile}

    exit 0
fi

if [[ $REPL_STAT == 1 ]]; then
    if [[ $CONFIG_ufds_is_master == "true" ]]; then
        echo "This is the UFDS master"
        exit 0
    fi

    ufds_uuid=`vmadm lookup -1 tags.smartdc_role=ufds`

    log=/var/svc/log/smartdc-application-ufds-replicator:default.log

    changelog_num=`nawk '{
            pos = index($0, "Updated changenumber to")
            if (pos == 0)
                next
            s = substr($0, pos + 24)
            pos = index(s, "\"") - 1
            n = substr(s, 1, pos)
        }
        END {print n}' /zones/$ufds_uuid/root/$log`

    egrep -s "No new changelog entries" /zones/$ufds_uuid/root/$log
    if [[ $? == 0 ]]; then
        echo "Replication is caught up"
        exit 0
    fi

    . /lib/sdc/config.sh
    load_sdc_config

    # determine approx. how many changelog entries we need to replicate
    echo "PATH=/opt/local/bin:/opt/local/sbin:/usr/bin:/usr/sbin:/opt/smartdc/ufds/build/node/bin:/opt/smartdc/ufds/node_modules/.bin" \
            >/zones/$ufds_uuid/root/tmp/cnt
    echo "LDAPTLS_REQCERT=allow ldapsearch -x -LLL" \
        "-H ldaps://$CONFIG_ufds_remote_ip -D $CONFIG_ufds_ldap_root_dn" \
        "-w $CONFIG_ufds_ldap_root_pw -b cn=changelogcount" \
        "'(&(objetclass=*))'" >>/zones/$ufds_uuid/root/tmp/cnt

    totcl=`zlogin $ufds_uuid bash /tmp/cnt | \
        nawk '{if ($1 == "count:") print $2}'`

    [[ -z "$totcl" || $totcl == 0 ]] && totcl=1

    pct=$((($changelog_num * 100) / $totcl))
    echo "$pct% of user data is replicated"

    exit 0
fi

if [[ -n "$UPDATE_CN" ]]; then
    . /lib/sdc/config.sh
    load_sdc_config

    OEN_ARGS="-t 30 -T 120 -c -n $UPDATE_CN"

    role_uuid=`vmadm lookup -1 tags.smartdc_role=assets`

    echo "Upgrading the agents on compute node $UPDATE_CN"

    ROOT=/var/cn_upgrade
    assetdir=/usbkey/extra/agents65
    mkdir -p $assetdir

    upgrade_agents

    echo "Compute node agent upgrade is complete"

    echo "Updating the VM configurations on compute node $UPDATE_CN"

    cp $ROOT/upd_cn /tmp

    sdc-oneachnode $OEN_ARGS "rm -f /tmp/upd_cn" >/dev/null
    [ $? != 0 ] && fatal "setting up compute node update"
    sdc-oneachnode $OEN_ARGS -g /tmp/upd_cn >/dev/null
    [ $? != 0 ] && fatal "copying compute node update file"

    sdc-oneachnode $OEN_ARGS "bash /tmp/upd_cn &" >/dev/null
    # ignore errors which are expected on a re-run

    echo "Compute node VM update is complete"

    exit 0
fi

if [[ $COMMIT == 1 ]]; then
    [ ! -d /var/usb_rollback ] && \
        fatal "nothing to commit: data does not exist"

    echo "-----------------------------------------------------------------"
    echo "Warning:"
    echo "This command will commit the upgrade and prevent future rollback."
    echo "-----------------------------------------------------------------"
    echo -n "Enter 'y' to continue: "
    read val
    [[ "$val" != "y" ]] && exit 0

    # Enable the new zfs features that we know about
    zpool set feature@async_destroy=enabled zones
    zpool set feature@empty_bpobj=enabled zones
    zpool set feature@lz4_compress=enabled zones
    zpool set feature@filesystem_limits=enabled zones
    zfs set compression=lz4 zones/cores

    for i in `zfs list -o name -H -t snapshot | egrep "rollback$"`
    do
        zfs destroy $i
    done

    for i in `zfs list -o name -H | egrep "_rollback$"`
    do
        zfs destroy -r $i
    done

    # We'd like to do the following:
    #    zfs destroy -r zones/pre-upgrade
    # but that will fail since the portal zone's snapshot & clone are still
    # needed. We've already renamed the portal zone, so just cleanup the
    # things we don't need.
    for i in `zfs list -o name | egrep "zones/pre-upgrade/[a-z][^-/]*$"`
    do
        origin=`zfs list -H -o origin $i`
        zfs destroy -r $i
        zfs destroy $origin
    done

    rm -rf /var/usb_rollback

    zpool upgrade zones

    echo "Updating smartlogin configuration on each compute node"
    load_sdc_config
    SLCFG=/opt/smartdc/agents/etc/smartlogin.cfg
    sdc-oneachnode -c "sed -e \
        \"s,^capi-url=.*,capi-url=$CONFIG_capi_client_url,\" \
        < $SLCFG > $SLCFG.new; mv $SLCFG.new $SLCFG"

    # Skip this, not really needed and the key is almost full so there will
    # be no room for a new platform.
    #
    # echo "Syncing datasets back to the USB key, this will take a while"
    # /usbkey/scripts/mount-usb.sh
    # (cd /usbkey/datasets && rsync -a * /mnt/usbkey/datasets)
    # umount /mnt/usbkey
fi

exit 0
