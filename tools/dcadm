#!/usr/bin/bash
#

# Important! This is just a place-holder until we rewrite in node.
#

exec 4>>/var/log/dcadm.log
export PS4='${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
export BASH_XTRACEFD=4
set -o xtrace

source /lib/sdc/config.sh
load_sdc_config

CURL_OPTS="-m 10 -sS -i"

# CNAPI!
CNAPI_IP=$(echo "${CONFIG_cnapi_admin_ips}" | cut -d ',' -f1)
if [[ -n ${CONFIG_cnapi_http_admin_user}
    && -n ${CONFIG_cnapi_http_admin_pw} ]]; then

    CNAPI_CREDENTIALS="${CONFIG_cnapi_http_admin_user}:${CONFIG_cnapi_http_admin_pw}"
fi
if [[ -n ${CNAPI_IP} ]]; then
    CNAPI_URL="http://${CNAPI_IP}"
fi

# ZAPI!
ZAPI_IP=$(echo "${CONFIG_zapi_admin_ips}" | cut -d ',' -f1)
if [[ -n ${CONFIG_zapi_http_admin_user}
    && -n ${CONFIG_zapi_http_admin_pw} ]]; then

    ZAPI_CREDENTIALS="${CONFIG_zapi_http_admin_user}:${CONFIG_zapi_http_admin_pw}"
fi
if [[ -n ${ZAPI_IP} ]]; then
    ZAPI_URL="http://${ZAPI_IP}"
fi

# NAPI!
NAPI_URL=${CONFIG_napi_client_url}

if [[ -n ${CONFIG_napi_http_admin_user}
    && -n ${CONFIG_napi_http_admin_pw} ]]; then

    NAPI_CREDENTIALS="${CONFIG_napi_http_admin_user}:${CONFIG_napi_http_admin_pw}"
fi

# WORKFLOW!
WORKFLOW_IP=$(echo "${CONFIG_workflow_admin_ips}" | cut -d ',' -f1)
if [[ -n ${CONFIG_workflow_http_admin_user}
    && -n ${CONFIG_workflow_http_admin_pw} ]]; then

    WORKFLOW_CREDENTIALS="${CONFIG_workflow_http_admin_user}:${CONFIG_workflow_http_admin_pw}"
fi
if [[ -n ${WORKFLOW_IP} ]]; then
    WORKFLOW_URL="http://${WORKFLOW_IP}"
fi

mode=$1
shift

fatal()
{
    echo "$@" >&2
    exit 1
}

usage()
{
    cat >&2 <<EOF
Usage: $0 <mode> [args]

  == Modes ==

  dataset-list
  machine-create [<file>]
  machine-list
  network-list
  sdc-create <role>
  sdc-destroy <uuid|alias>
  sdc-list
  server-list

  cnapi [raw curl args]
  napi  [raw curl args]
  workflow [raw curl args]
  zapi  [raw curl args]

EOF
    exit 1
}

cnapi()
{
    path=$1
    shift
    curl ${CURL_OPTS} -u "${CNAPI_CREDENTIALS}" --url "${CNAPI_URL}${path}" "$@" \
        || exit
    echo ""  # sometimes the result is not terminated with a newline
}

napi()
{
    path=$1
    shift
    curl ${CURL_OPTS} -u "${NAPI_CREDENTIALS}" --url "${NAPI_URL}${path}" "$@" \
        || exit
    echo ""  # sometimes the result is not terminated with a newline
}

workflow()
{
    path=$1
    shift
    curl ${CURL_OPTS} -u "${WORKFLOW_CREDENTIALS}" --url "${WORKFLOW_URL}${path}" "$@" \
        || exit
    echo ""  # sometimes the result is not terminated with a newline
}

zapi()
{
    path=$1
    shift
    curl ${CURL_OPTS} -u "${ZAPI_CREDENTIALS}" --url "${ZAPI_URL}${path}" "$@" \
        || exit
    echo ""  # sometimes the result is not terminated with a newline
}

machine_list()
{
    printf "%-12s %-16s %-36s  %-6s %7s %16s\n" \
        "ALIAS" "SERVER" "UUID" "BRAND" "RAM" "STATE"

    # this sets the variables:
    #
    #  hostname_UUID=<hostname>
    #
    # with uuid's dashes changed to underscore to meet bash's variable name requirements.
    host_mappings=$(cnapi /servers \
        | json -H -e 'uuid=uuid.replace(/\-/g, "_");' -a uuid hostname \
        | tr ' ' '=' | sed -e "s/^\([0-9a-f].*$\)/local hostname_\\1/")
    if [[ -n ${host_mappings} ]]; then
       eval ${host_mappings}
    fi

    for zone in $(zapi /machines?state=active \
	    | json -H \
        -e 'alias=(alias || "-")' \
        -a alias brand state uuid ram server_uuid \
        | tr ' ' ',' | sort); do

        local alias=$(echo "${zone}" | cut -d',' -f1)
        local brand=$(echo "${zone}" | cut -d',' -f2)
        local state=$(echo "${zone}" | cut -d',' -f3)
        local uuid=$(echo "${zone}" | cut -d',' -f4)
        local ram=$(echo "${zone}" | cut -d',' -f5)
        local server_uuid=$(echo "${zone}" | cut -d',' -f6)
        local server_name=$(eval echo \${hostname_$(echo ${server_uuid} | tr '-' '_')})
        [[ -z ${server_name} ]] && server_name="-"

        printf "%-12s %-16s %-36s  %-6s %7s %16s\n" \
            "${alias}" "${server_name}" "${uuid}" "${brand}" "${ram}" "${state}"
    done
}

network_list()
{
    printf "%-12s %-36s  %-4s %16s %16s\n" \
        "NAME" "UUID" "VLAN" "NETWORK" "GATEWAY"
    printf "%-12s %36s  %4s %16s %16s\n" \
        $(napi /networks \
            | json -H \
            -a name uuid vlan network gateway)
}

dataset_list()
{
    local ds

    # XXX: CNAPI doesn't seem to support this right now, so get this from
    # the usbkey for now
    printf "%-12s %-8s %-36s\n" \
        "NAME" "VERSION" "UUID"
    for ds in /usbkey/datasets/*.dsmanifest; do
        printf "%-12s %-8s %-36s\n" \
            $(json -a name version uuid < ${ds})
    done
}

server_list()
{
    # XXX I want admin_ip here but it's not in the output (yet?)
    printf "%-12s %-36s  %7s\n" \
        "HOSTNAME" "UUID" "RAM"
    printf "%-12s %36s  %7s\n" \
        $(cnapi /servers \
            | json -H \
            -e 'memory_total_bytes=parseInt(memory_total_bytes / (1024 * 1024))' \
            -a hostname uuid memory_total_bytes)
}

add_config_ips()
{
    role=$1
    admin_ip=$2
    external_ip=$3

    /usbkey/scripts/mount-usb.sh >/dev/null 2>&1
    [[ $? != 0 ]] && fatal "unable to mount the USB key"

    for net in admin external; do
        this_ip=$( eval echo \${$(echo ${net}_ip)} )
        if [[ -n ${this_ip} ]]; then
            existing_ips=$(grep "^${role}_${net}_ips=" /mnt/usbkey/config \
                | cut -d'=' -f2 | tr -d ' ' | tr ',' ' ')
            new_ips=$( (for ip in ${existing_ips}; do echo ${ip}; done; \
                echo ${this_ip}) | sort | uniq | xargs | tr ' ' ',')
            if [[ -z ${existing_ips} ]]; then
                # remove the empty key if it exists
                grep -v "^${role}_${net}_ips=" /mnt/usbkey/config \
                    > /mnt/usbkey/config.new
                echo "${role}_${net}_ips=${new_ips}" >> /mnt/usbkey/config.new
                mv /mnt/usbkey/config.new /mnt/usbkey/config
            elif [[ $(echo "${existing_ips}" | wc -c) \
                -lt $(echo "${new_ips}" | wc -c) ]]; then

                # new list is longer
                sed -i "" -e \
                    "s/^${role}_${net}_ips=.*$/${role}_${net}_ips=${new_ips}/" \
                    /mnt/usbkey/config
            fi
        fi
    done

    # if the zone has its own additional update_config script, call that now
    # it can update the /mnt/usbkey/config if it needs to, and any other
    # config options
    if [[ -x /usbkey/zones/${role}/update_config ]]; then
        /usbkey/zones/${role}/update_config
    fi

    cmp /mnt/usbkey/config /usbkey/config >/dev/null 2>&1 \
        || cp /mnt/usbkey/config /usbkey/config
    umount /mnt/usbkey

    # update zoneconfig for any zone that has these keys
    for z in $(ls -1 /usbkey/zones); do
        if [[ -f /usbkey/zones/${z}/zoneconfig ]]; then
            grep "=.*${role}_.*_ips" /usbkey/zones/${z}/zoneconfig \
                >/dev/null 2>&1 \
                && update_zoneconfig ${z}
        fi
    done
}

del_config_ips()
{
    role=$1
    zone_ips=$2

    /usbkey/scripts/mount-usb.sh >/dev/null 2>&1
    [[ $? != 0 ]] && fatal "unable to mount the USB key"

    admin_ips=$(grep "^${role}_admin_ips=" /mnt/usbkey/config)
    external_ips=$(grep "^${role}_external_ips=" /mnt/usbkey/config)
    new_admin=${admin_ips}
    new_external=${external_ips}

    for ip in ${zone_ips}; do
        new_admin=$(echo "${new_admin}" \
            | sed -e "s/\([=,]\)${ip},/\1/" \
            | sed -e "s/\([=,]\)${ip}$/\1/" \
            | sed -e "s/,$//")
        new_external=$(echo "${new_external}" \
            | sed -e "s/\([=,]\)${ip},/\1/" \
            | sed -e "s/\([=,]\)${ip}$/\1/" \
            | sed -e "s/,$//")
    done

    sed -e "s/^${role}_admin_ips=.*$/${new_admin}/" /mnt/usbkey/config \
        | sed -e "s/^${role}_external_ips=.*$/${new_external}/" \
        > /mnt/usbkey/config.new

    if ! cmp /mnt/usbkey/config.new /mnt/usbkey/config >/dev/null 2>&1; then
        mv /mnt/usbkey/config.new /mnt/usbkey/config
    else
        rm -f /mnt/usbkey/config.new
    fi

    # if the zone has its own additional update_config script, call that now
    # it can update the /mnt/usbkey/config if it needs to, and any other
    # config options
    if [[ -x /usbkey/zones/${role}/update_config ]]; then
        /usbkey/zones/${role}/update_config
    fi

    if ! cmp /mnt/usbkey/config /usbkey/config >/dev/null 2>&1; then
        cp /mnt/usbkey/config /usbkey/config
    fi

    umount /mnt/usbkey

    # update zoneconfig for any zone that has these keys
    for z in $(ls -1 /usbkey/zones); do
        if [[ -f /usbkey/zones/${z}/zoneconfig ]]; then
            grep "=.*${role}_.*_ips" /usbkey/zones/${z}/zoneconfig \
                >/dev/null 2>&1 \
                && update_zoneconfig ${z}
        fi
    done
}

next_alias()
{
    local zrole=$1
    local zone=
    local idx=0

    local all_zones=$(zapi "/machines?owner_uuid=${CONFIG_ufds_admin_uuid}&state=active" \
        | json -H -e 'alias=(alias || "-")' -e 'smartdc_role=(tags.smartdc_role || "-")' \
        -a smartdc_role alias | tr ' ' ',')

    # 100 here for runaway protection
    while [[ ${idx} -lt 100 ]]; do
        local found=0
        for zone in ${all_zones}; do
            local role=${zone%%,*}
            local alias=${zone##*,}

            if [[ ${role} == ${zrole} && ${alias} == "${zrole}${idx}" ]]; then
                found=1
            fi
        done

        # if it wasn't found, we'll use this one
        [[ ${found} == 0 ]] && break

        idx=$((${idx} + 1))
    done

    [[ ${idx} == 100 ]] && fatal "next_alias(${zrole}): alias overflow"

    echo "${zrole}${idx}"
}

add_pkg_zone_parameters()
{
    zrole=$1

    local package=$(eval "echo \${CONFIG_${zrole}_pkg}")
    if [[ -z ${package} ]]; then
        fatal "${zrole}: unable to determine package."
    fi

    local pkg=
    local idx=0
    while [[ -n $(eval "echo \${CONFIG_pkg_${idx}}") ]]; do
        pkg=$(eval "echo \${CONFIG_pkg_${idx}}")
        if [[ ${pkg%%:*} == ${package} ]]; then
            # name:ram:swap:disk:cap:nlwp:iopri
            local ram=$(echo ${pkg} | cut -d ':' -f 2)
            local swap=$(echo ${pkg} | cut -d ':' -f 3)
            local disk=$(echo ${pkg} | cut -d ':' -f 4)
            local cap=$(echo ${pkg} | cut -d ':' -f 5)
            local nlwp=$(echo ${pkg} | cut -d ':' -f 6)
            local iopri=$(echo ${pkg} | cut -d ':' -f 7)

            [[ -n ${ram} ]] \
                && zone_parameters="${zone_parameters}, ram: ${ram}"
            [[ -n ${swap} ]] \
                && zone_parameters="${zone_parameters}, max_swap: ${swap}"
            [[ -n ${disk} ]] \
                && zone_parameters="${zone_parameters}, quota: ${disk}"
            [[ -n ${cap} ]] \
                && zone_parameters="${zone_parameters}, cpu_cap: ${cap}"
            [[ -n ${nlwp} ]] \
                && zone_parameters="${zone_parameters}, max_lwps: ${nlwp}"
            [[ -n ${iopri} ]] \
                && zone_parameters="${zone_parameters}, zfs_io_priority: ${iopri}"
        fi
        idx=$((${idx} + 1))
    done
}

get_zone_parameters()
{
    local zrole=$1
    local setup_json="/usbkey/zones/${zrole}/setup.json"

    if [[ ! -f ${setup_json} ]]; then
        fatal \
            "${zrole}: missing setup.json file in /usbkey/config/zones/${zrole}"
    fi

    # This is where results go!
    zone_parameters="{ brand: 'joyent'"

    local dataset=$(cat /usbkey/zones/${zrole}/dataset | head -1)
    if [[ -z ${dataset} || ! -f /usbkey/datasets/${dataset}.dsmanifest ]]; then
        fatal "${zrole}: has missing/invalid dataset version."
    fi
    dataset=$(json uuid < /usbkey/datasets/${dataset}.dsmanifest)
    if [[ -z ${dataset} ]]; then
        fatal "${zrole}: unable to find dataset uuid."
    fi
    zone_parameters="${zone_parameters}, dataset_uuid: '${dataset}'"
    zone_parameters="${zone_parameters}, owner_uuid: '${CONFIG_ufds_admin_uuid}'"

    local primary_network=$(json primary_network < ${setup_json})
    local all_networks=$(napi /networks | json -H -a name uuid | tr ' ' ',')
    local networks=$( (json networks | json -a) < ${setup_json} | xargs)
    local primary_uuid=
    local net_uuids=
    local all_net=
    local net=

    for net in ${networks}; do
        for all_net in ${all_networks}; do
            if [[ ${all_net%%,*} == ${net} ]]; then
                if [[ -z ${net_uuids} ]]; then
                    net_uuids="\"${all_net##*,}\""
                else
                    net_uuids="${net_uuids},\"${all_net##*,}\""
                fi
            fi
            if [[ ! -z {$primary_network} \
                && ${all_net%%,*} == ${primary_network} ]]; then

                primary_uuid=${all_net##*,}
            fi
        done
    done

    zone_parameters="${zone_parameters}, networks: [${net_uuids}]"

    if [[ -n ${primary_uuid} ]]; then
        zone_parameters="${zone_parameters}, primary_network: '${primary_uuid}'"
    fi

    # check for delegated dataset
    if [[ $(json delegate_dataset < ${setup_json}) == "true" ]]; then
        zone_parameters="${zone_parameters}, delegate_dataset: true"
    fi

    # find the next alias
    zone_parameters="${zone_parameters}, alias: '$(next_alias ${zrole})'"

    # add suff that comes from the pkg
    add_pkg_zone_parameters ${zrole}
}

setup_zone_files()
{
    zrole=$1

    local extra_root=/usbkey/extra
    local assetdir=${extra_root}/${zrole}
    local srcdir=/usbkey/zones/${zrole}

    mkdir -p ${assetdir}
    for file in backup bashrc configure fs.tar.bz2 pkgsrc restore setup; do
    if [[ -f ${srcdir}/${file} ]]; then
        cp -f ${srcdir}/${file} ${assetdir}/${file}
    fi
    done
    cp -f /usbkey/default/*.common ${assetdir}/
}

update_zoneconfig()
{
    zrole=$1

    in_filename=/usbkey/zones/${zrole}/zoneconfig
    out_filename=/usbkey/extra/${zrole}/zoneconfig

    if [[ ! -f ${in_filename} ]]; then
        fatal "FATAL: ${in_filename} does not exist."
    fi

    mkdir -p /usbkey/extra/${zrole}

    # (re)create the zoneconfig file
    (
        . /usbkey/config
        . /usbkey/config.inc/generic
        . ${in_filename}
        for var in $(cat ${in_filename} \
        | grep -v "^ *#" | grep "=" | cut -d'=' -f1); do
        echo "${var}='${!var}'"
        done
    ) > ${out_filename}
}

sdc_create()
{
    local zrole=$1
    local networks=

    if [[ -z ${zrole} ]]; then
        usage
    fi

    zone_parameters=
    get_zone_parameters ${zrole}
    setup_zone_files ${zrole}

    # update config that zone uses, before provision in case something changed.
    update_zoneconfig "${zrole}"

    # above we added: { ..., so now we need to close the curlies.
    zone_parameters="${zone_parameters} }"

    # create mdata temp file
    tmpfile="/tmp/payload.$$"
    node -e "
        fs = require('fs');
        us = fs.readFileSync('/usbkey/default/user-script.common', 'utf-8');
        o = ${zone_parameters};
        o.tags = {};
        o.tags['smartdc_role'] = '${zrole}';
        o.customer_metadata = {};
        o.customer_metadata['assets-ip'] = '${CONFIG_assets_admin_ip}';
        o.customer_metadata['user-script'] = us.toString();
        fs.writeFileSync('${tmpfile}', JSON.stringify(o, null, 2), 'utf-8');" \
        >&4 2>&1

    if [[ $? != 0 || ! -f ${tmpfile} ]]; then
        echo "Unable to convert user script to JSON." >&2
        exit 1
    fi

    echo "=== BEGIN PAYLOAD ===" >&4
    cat ${tmpfile} >&4
    echo "===  END PAYLOAD  ===" >&4

    provision_zone_from_payload ${tmpfile}

    if [[ $? == 0 ]]; then
        # created successfully
        local admin=
        local external=
        local result=$(napi /nics?belongs_to_uuid=${provisioned_uuid} | json -H -a nic_tag ip | tr ' ' '=')
        eval "${result}"
        if [[ -z ${admin} ]]; then
            fatal "unable to find Admin IP for ${provisioned_uuid}"
        fi
        add_config_ips "${zrole}" "${admin}" "${external}"
    fi
}

# filename passed must have a 'Job-Location: ' header in it.
watch_job()
{
    local filename=$1

    # This may in fact be the hackiest possible way I could think up to do this
    rm -f /tmp/job_status.$$.old
    touch /tmp/job_status.$$.old
    local prev_execution=
    local chain_results=
    local execution=
    local job_status=
    local loop=0
    while [[ ${execution} != 'succeeded' && ${execution} != "failed" && ${loop} -lt 120 ]]; do
        local job=$(grep "^Job-Location:" ${filename} | cut -d ' ' -f2 | tr -d [:space:])
        if [[ -n ${job} ]]; then
            job_status=$(workflow ${job} | json -H)
            echo "${job_status}" | json chain_results | json -a result > /tmp/job_status.$$.new
            diff -u /tmp/job_status.$$.old /tmp/job_status.$$.new | grep -v "No differences encountered" | grep "^+[^+]" | sed -e "s/^+/+ /"
            mv /tmp/job_status.$$.new /tmp/job_status.$$.old
            execution=$(echo "${job_status}" | json execution)
            if [[ ${execution} != ${prev_execution} ]]; then
                echo "+ Job status changed to: ${execution}"
                prev_execution=${execution}
            fi
        fi
        sleep 0.5
    done
    if [[ ${execution} == "succeeded" ]]; then
        echo "+ Success!"
        return 0
    else
        echo "+ FAILED! (details in ${job})"
        return 1
    fi
}

sdc_destroy()
{
    local arg=$1

    local zone=
    local destroy_uuid=
    for zone in $(zapi "/machines?owner_uuid=${CONFIG_ufds_admin_uuid}&state=active" \
        | json -H -e 'alias=(alias || "-")' \
        -e 'smartdc_role=(tags.smartdc_role || "-")' \
        -e 'smartdc_type=(tags.smartdc_type || "-")' \
        -a uuid smartdc_role smartdc_type alias | tr ' ' ','); do

        local uuid=${zone%%,*}
        local zrole=$(echo "${zone}" | cut -d ',' -f2)
        local ztype=$(echo "${zone}" | cut -d ',' -f3)
        local alias=${zone##*,}

        if [[ -z ${zrole} || ${zrole} == "-" ]]; then
            echo "sdc_destroy: zone '${arg}' has no smartdc_role." >&2
            continue
        fi

        if [[ -z $(eval echo \${${zrole}_count}) ]]; then
            eval ${zrole}_count=1
        else
            eval ${zrole}_count=$(($(eval echo \${${zrole}_count}) + 1))
        fi

        if [[ ${uuid} == ${arg} || ${alias} == ${arg} ]]; then
            [[ -n ${destroy_uuid} ]] && fatal "More than one zone found matching: '${arg}'"
            destroy_uuid=${uuid}
            destroy_zrole=${zrole}
        fi
    done

    [[ -z ${destroy_uuid} ]] && fatal "sdc_destroy: unable to find uuid for zone matching '${arg}'"

    if [[ $(eval echo \${${destroy_zrole}_count}) -le 1 && ${ztype} == "core" ]]; then
        fatal "Cannot remove last ${destroy_zrole} zone (this is a core zone)."
    fi

    # Find the IPs that NAPI thinks the zone has so we can remove them
    local zone_ips=$(napi /nics?belongs_to_uuid=${destroy_uuid} | json -H -a ip | xargs)

    zapi /machines/${destroy_uuid} -X DELETE | tee /tmp/destroy.$$ >&4

    echo "+ Sent DELETE to ZAPI for ${destroy_uuid}"
    watch_job /tmp/destroy.$$

    if [[ $? == 0 ]]; then
        # it's destroyed! Go ahead and remove IPs now.
        del_config_ips "${destroy_zrole}" "${zone_ips}"
    fi
}

provision_zone_from_payload()
{
    local tmpfile=$1
    local verbose="$2"
    zapi /machines -X POST -H "Content-Type: application/json" --data-binary @${tmpfile} 2>&1 | tee /tmp/provision.$$ >&4
    provisioned_uuid=$(json -H uuid < /tmp/provision.$$)
    if [[ -z ${provisioned_uuid} ]]; then
        if [[ -n $verbose ]]; then
            cat /tmp/provision.$$ | json -H
            exit 1
        else
            fatal "unable to get uuid for new ${zrole} machine."
        fi
    fi

    echo "+ Sent provision to ZAPI for ${provisioned_uuid}"
    watch_job /tmp/provision.$$

    return $?
}

machine_create()
{
    local filename=$1

    if [[ -z ${filename} || ${filename} == "-" ]]; then
        echo "machine_create: reading from stdin" >&2
        filename="/dev/stdin"
    fi
    if [[ ! -e ${filename} ]]; then
        fatal "unable to find file '${filename}'"
    fi
    provision_zone_from_payload "${filename}" "true"

    return $?
}

sdc_list()
{
    local zone=

    printf "%-12s %-16s %-36s  %-7s %10s %16s\n" \
        "ALIAS" "SERVER" "UUID" "RAM" "STATE" "ROLE"

    # this sets the variables:
    #
    #  hostname_UUID=<hostname>
    #
    # with uuid's dashes changed to underscore to meet bash's variable name requirements.
    host_mappings=$(cnapi /servers \
        | json -H -e 'uuid=uuid.replace(/\-/g, "_");' -a uuid hostname \
        | tr ' ' '=' | sed -e "s/^\([0-9a-f].*$\)/local hostname_\\1/")
    if [[ -n ${host_mappings} ]]; then
       eval ${host_mappings}
    fi

    for zone in $(zapi "/machines?owner_uuid=${CONFIG_ufds_admin_uuid}&state=active" \
        | json -H -e 'smartdc_role=(tags.smartdc_role || "-")' \
            -a alias smartdc_role state uuid ram server_uuid \
        | tr ' ' ',' | sort); do

        local alias=$(echo "${zone}" | cut -d',' -f1)
        local role=$(echo "${zone}" | cut -d',' -f2)
        local state=$(echo "${zone}" | cut -d',' -f3)
        local uuid=$(echo "${zone}" | cut -d',' -f4)
        local ram=$(echo "${zone}" | cut -d',' -f5)
        local server_uuid=$(echo "${zone}" | cut -d',' -f6)
        local server_name=$(eval echo \${hostname_$(echo ${server_uuid} | tr '-' '_')})
        [[ -z ${server_name} ]] && server_name="-"

        printf "%-12s %-16s %-36s  %-7s %10s %16s\n" \
            "${alias}" "${server_name}" "${uuid}" "${ram}" "${state}" "${role}"
    done
}

if [[ -z ${mode} ]]; then
    usage
fi

case ${mode} in
dataset-list)
    dataset_list "$@"
;;
machine-create)
    machine_create "$@"
;;
machine-list)
    machine_list "$@"
;;
network-list)
    network_list "$@"
;;
sdc-create)
    sdc_create "$@"
;;
sdc-destroy)
    sdc_destroy "$@"
;;
sdc-list)
    sdc_list "$@"
;;
server-list)
    server_list "$@"
;;
cnapi)
    cnapi "$@"
;;
napi)
    napi "$@"
;;
workflow)
    workflow "$@"
;;
zapi)
    zapi "$@"
;;
*)
    echo "Illegal mode: ${mode}" >&2
    usage
;;
esac

exit 0
