#!/usr/bin/bash

#
# Copyright (c) 2012, Joyent, Inc. All rights reserved.
#

unset LD_LIBRARY_PATH
PATH=/usr/bin:/usr/sbin:/opt/smartdc/bin
export PATH

STANDBY_PATH="/mnt/usbkey/standby"

# This writes xtrace output and anything redirected to LOGFD to the log file.
LOGFD=4
exec 4>/tmp/backuplog.$$
export PS4='${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
export BASH_XTRACEFD=${LOGFD}
set -o xtrace

usage()
{
	printf "usage: $(basename $0) [-d directory | -l | -U device | -s zone]\n" >/dev/stderr
	exit 1
}

warn()
{
	printf "Warning: %s\n" "$1" >/dev/stderr
}

fatal()
{
	printf "Error: %s\n" "$1" >/dev/stderr
	exit 1
}

cleanup()
{
	cd /zones
	rm -rf $dest
}

# Refresh the backup/restore scripts in the assets zone so compute nodes
# use up-to-date code.
refresh_assets()
{
	# get mapi owner UUID - this is the "admin" user
	admin_uuid=$CONFIG_ufds_admin_uuid

	for i in `ls -d /usbkey/zones/*`
	do
		zone=${i##*/}

		# This only returns if there's exactly 1, if we want to support
		# multiple zones with the same role on one machine, this needs
		# to be fixed.
		uuid=$(vmadm lookup -1 owner_uuid=${admin_uuid} \
		    tags.smartdc_role=${zone} 2>/dev/null)
		# Assume that if we have backup, we have restore too.
		[ ! -e /usbkey/zones/${uuid}/backup ] && continue

		assetdir=/usbkey/extra/$zone
		mkdir -p $assetdir
		cp /usbkey/zones/${uuid}/backup \
		    /usbkey/zones/${uuid}/restore $assetdir
	done
}

# Get list of all smartdc role zones on this node.
get_smartdc_zones()
{
	smartdc_zones=""

	# get ufds admin UUID - this is the "admin" user
	if [[ -z ${CONFIG_ufds_admin_uuid} ]]; then
		. /lib/sdc/config.sh
		load_sdc_config
	fi
	admin_uuid=${CONFIG_ufds_admin_uuid}
	if [[ -z ${admin_uuid} ]]; then
		echo "Failed to get admin_uuid, check your config." >&2
		exit 1
	fi

	smartdc_zones=$(for zone in \
	    $(vmadm lookup owner_uuid=${admin_uuid} tags.smartdc_role=~^[a-z])
	do
		values=$(vmadm list -p -o tags.smartdc_role,uuid uuid=${zone})
		uuid=${values##*:}
		role=${values%%:*}
		echo "${uuid},${role}"
	done)

	echo ${smartdc_zones}
}

# $1 zone
# $2 tag
backup()
{
	# Pull over the role's backup script
	mkdir /tmp/backup.$$
	curl -k -o /tmp/backup.$$/backup \
	    -s http://$CONFIG_assets_admin_ip/extra/$2/backup

	# Check if we got an <html> file not found.
	# That means that this role has no backup script.
	hd=$(dd if=/tmp/backup.$$/backup bs=1 count=6 2>/dev/null)
	if [ "$hd" == "<html>" ]; then
		echo "Skipping zone $2 ($1), stateless"
		rm -rf /tmp/backup.$$
		return
	fi

	echo "Backing up the $2 zone $1"

	chmod +x /tmp/backup.$$/backup
	/tmp/backup.$$/backup $1 $dest >/dev/null 2>&1
	res=$?
	[ $res != 0 ] && fatal "$res backing up $1"

	rm -rf /tmp/backup.$$
}

# We mount the usb using this function instead of the CLI so we can ensure
# there is no conflict with our disk (in case it already has a backup on it
# and we are overwriting it) and so we can mount without foldcase. That is
# necessary so that the file system names match the GRUB menu entries (which
# use upper-case characters).
mount_usb()
{
	zfs_disks=`zpool status | nawk '{
		if ($1 == "pool:") next
		if ($1 == "state:") next
		if ($1 == "scan:") next
		if ($1 == "config:") next
		if ($1 == "NAME") {
			skip_next=1
			next
		}
		if ($1 == "errors:") next

		if (skip_next)
			skip_next=0
		else
			print $1
	}'`

	USBKEYS=`/usr/bin/disklist -a`
	for key in ${USBKEYS}; do
		[[ "$key" == "$DISK" ]] && continue

		skip=0
		for zd in $zfs_disks; do
			[ "$zd" == "$key" ] && skip=1
		done
		[ $skip == 1 ] && continue

		if [[ `/usr/sbin/fstyp /dev/dsk/${key}p0:1` == 'pcfs' ]]; then
			mount -F pcfs -o noatime /dev/dsk/${key}p0:c /mnt/usbkey
			if [[ $? == "0" ]]; then
				if [[ ! -f /mnt/usbkey/.joyliveusb ]]; then
					umount /mnt/usbkey
				else
					echo "mounting USB disk $key"
					break;
				fi
			fi
		fi
	done

	mounted=`mount -p | nawk '{if ($3 == "/mnt/usbkey") print $3}'`
	[ -z "$mounted" ] && fatal "could not mount the USB key"
}

copy_usb()
{
	# check if usb key already mounted
	mounted=`mount -p | nawk '{if ($3 == "/mnt/usbkey") print $3}'`
	[ -n "$mounted" ] && fatal "the USB key is currently mounted"

	if [ "$usbdev" == "-" ]; then
		mount_usb 1>&2
		echo "copying files" 1>&2
		(cd /mnt/usbkey; tar cbfE 512 - * .joyliveusb)
		umount /mnt/usbkey 1>&2
		rm -f /tmp/exclude.$$
		echo "done" 1>&2
		exit 0
	fi

	# Strip name down to cXtXdX name no matter how it was input
	# (with raw or block or no path, or with pX or sX or no suffix).
	bname=${usbdev##*/}
	bname=${bname%p[0-9]}
	DISK=${bname%s[0-9]}

	RDISK=/dev/rdsk/${DISK}p0
	BDISK=/dev/dsk/${DISK}p0

	[ ! -c "$RDISK" ] && fatal "the device $RDISK does not exist"
	[ ! -b "$BDISK" ] && fatal "the device $BDISK does not exist"

	# Note: entire disk will be cleared, all data lost and a new image
	# created.  Confirm unless -F given.
	if [ $FORCE != 1 ]; then
		printf \
		    "Disk %sp0 will relabled, reformatted %s"\
		    ${DISK} \
		    "and all data will be lost [y/n] "

		read resp
		[ "$resp" != "y" ] && exit 0
	fi

	echo "labeling disk"
	# First clear label since fdisk -g fails on a labeled disk
	dd if=/dev/zero of=$RDISK count=2 >/dev/null 2>&1 || \
	    fatal "unable to clear old label"

	nsect=`fdisk -g $RDISK | nawk '{
	    if ($1 == "*") next
		print $1 * $5 * $6
	}'`

	[[ $nsect -lt 7800000 ]] && fatal "disk must be at least 4GB" 

	# fdisk input: 12 (id) is FAT32 Ext., 128 is active
	printf "12 128 0 0 0 0 0 0 4096 %d\n" $nsect >/tmp/fdisk$$.in

	fdisk -F /tmp/fdisk$$.in $RDISK || fatal "labeling disk"

	rm -f /tmp/fdisk$$.in

	echo "creating PCFS file system"
	echo "y" | \
	    mkfs -F pcfs -o B=/usbkey/boot/grub/stage1,fat=32 ${RDISK}:c || \
	    fatal "making PCFS file system"
	echo "mounting target disk $DISK"
	mkdir -p /key
	mount -F pcfs -o noatime ${BDISK}:c /key || \
	   fatal "mounting file system"

	mount_usb

	echo "copying files"
	(cd /mnt/usbkey; tar cbfE 512 - *) | (cd /key; tar xbf 512 -)
	[ $? != 0 ] && fatal "copying files"
	touch /key/.joyliveusb

	umount /key
	umount /mnt/usbkey

	echo "setting up grub"
	printf "(hd0) %s\n" $BDISK >/tmp/grub$$.map
	printf "root (hd0,0)\nsetup (hd0)\n" | grub --device-map=/tmp/grub$$.map
	[ $? != 0 ] && fatal "installing grub boot blocks"
	rm -f /tmp/grub$$.map

	echo "done"
	exit 0
}

check_disk_master()
{
	master=""

	local ftype=`fstyp /dev/dsk/$1:1 2>/dev/null`
	[[ "$ftype" != "pcfs" ]] && return

	mount -F pcfs -o foldcase,noatime /dev/dsk/$1:1 /mnt/usbkey
	[[ $? != 0 ]] && return

	[[ -f /mnt/usbkey/.joyliveusb ]] && master="(master)"
	umount /mnt/usbkey
}

#
# We include code to support the coal non-usb bootable device.
# Note that multiple disks can be marked "master" if they are setup that way.
#
show_usb()
{
	# check if usb key already mounted
	local mounted=`mount -p | nawk '{if ($3 == "/mnt/usbkey") print $3}'`
	[ -n "$mounted" ] && fatal "the USB key is currently mounted"

	# If in a VM, handle the simulated coal USB disk.
	local platform=$(smbios -t1 | nawk '{if ($1 == "Product:") print $2}')
	if [ "$platform" == "VMware" ]; then
		local DISKS=`disklist -a`
		for key in ${DISKS}; do
			local dname="${key}p0"

			check_disk_master "$dname"
			[ -n "$master" ] && echo "$dname $master"
		done
	fi

	# Now try to get the actual removable disks via rmformat.
	local DISKS=`rmformat | nawk '{
		if ( $1 ~ /[0-9]+\./ ) {
			n = split($4, f, "/")
			dname = f[n]
			skip = 0
		}

		if ($1 == "Bus:" && $2 != "USB")
			skip = 1
		if ($1 == "Device" && $3 != "Removable")
			skip = 1

		if ($1 == "Access" && ! skip)
			printf("%s ", dname)

	}'`
	for dname in ${DISKS}; do
		check_disk_master "$dname"
		echo "$dname $master"
	done

	exit 0
}

#
# Main body
#

# Load config variables with CONFIG_ prefix
. /lib/sdc/config.sh
load_sdc_config

headnode=1
[[ `sysinfo | json '["Boot Parameters"].headnode'` != "true" ]] && \
    headnode=0

destdir=/zones
doshow=0
dostandby=0
FORCE=0
skip_zones=""

while getopts "d:FlSs:U:" opt
do
	case "$opt" in
		d)	destdir=$OPTARG;;
		F)	FORCE=1;;
		l)	doshow=1;;
		s)	skip_zones="$OPTARG $skip_zones";;
		S)	dostandby=1
			destdir=$STANDBY_PATH;;
		U)	usbdev=$OPTARG;;
		*)	usage;;
	esac
done

[ $headnode == 0 -a $doshow == 1 ] && \
    fatal "-l is only valid on the headnode"
[ $headnode == 0 -a -n "$usbdev" ] && \
    fatal "-U is only valid on the headnode"
[ $headnode == 0 -a $dostandby == 1 ] && \
    fatal "-S is only valid on the headnode"

[ $destdir != "/zones" -a -n "$usbdev" ] && usage
[ $doshow == 1 -a $destdir != "/zones" ] && usage
[ $doshow == 1 -a -n "$usbdev" ] && usage
[ $doshow == 1 -a $dostandby == 1 ] && usage
[ $dostandby == 1 -a -n "$skip_zones" ] && usage
[ $dostandby == 1 -a $destdir != $STANDBY_PATH ] && usage

[ $doshow == 1 ] && show_usb

[ -n "$usbdev" ] && copy_usb

dest=/zones/tmp_bu.$$
trap cleanup EXIT

mkdir -p ${dest} || fatal "unable to create backup directory $dest"
mkdir -p ${dest}/global || \
    fatal "unable to create backup directory $dest/global"

#
# If on the headnode, backup datasets, USB key config and GZ config.
#
if [ $headnode == 1 ]; then
	#
	# Whenever we backup the headnode, refresh the backup scripts in the
	# assets zone so compute node backups use up to date code.
	#
	refresh_assets

	# Make sure config files are up to date
	sdc-image-sync

	cp -pr /usbkey/config* $dest || \
	    fatal "unable to copy configuration to $dest"
	[ ! -f "$dest/config" ] && fatal "missing headnode config file"

	do_backup=1
	for skip in $skip_zones
	do
		if [ $skip == "datasets" ]; then
			do_backup=0
			break
		fi
	done
	if [ $do_backup == 1 ]; then
		echo "Backing up datasets"
		cp -pr /usbkey/datasets $dest || \
		    fatal "unable to copy datasets to $dest"
	else
		echo "Skipping datasets"
	fi

	# Backup GZ config
	[ -f /opt/smartdc/agents/etc/smartlogin.cfg ] && \
	    cp /opt/smartdc/agents/etc/smartlogin.cfg ${dest}/global
fi

# Now backup any extra zones on this node
for i in $(get_smartdc_zones); do # we get a tuple of uuid,tag
	uuid=${i%%,*}
	tag=${i##*,}

	do_backup=1
	for skip in $skip_zones
	do
		if [ $skip == $tag ]; then
			do_backup=0
			break
		fi
	done

	echo $tag >>${dest}/zones.lst
	if [ $do_backup == 1 ]; then
		backup $uuid $tag
	else
		echo "Skipping $zone (${uuid})"
	fi
done

if [ $headnode == 1 ]; then
	# Create a signature we can use in sdc-restore to validate the backup
	sum -x md5 /usbkey/config | cut -d' ' -f1 >$dest/backup.sum
fi

get_smartdc_zones >$dest/zones.uuids

echo "creating backup file"
(cd $dest && tar cbfE 512 - *) | gzip >/zones/tmp_bu.$$.tgz || \
    fatal "writing to file /zones/tmp_bu.$$.tgz"

if [ $dostandby == 1 ]; then
	# check if usb key already mounted
	mounted=`mount -p | nawk '{if ($3 == "/mnt/usbkey") print $3}'`
	[ -z "$mounted" ] && mount_usb

	bu_size=`ls -lk /zones/tmp_bu.$$.tgz | nawk '{print $5}'`
	key_free=`df -k /mnt/usbkey | nawk '{if ($4 != "avail") print $4}'`
	if [ $bu_size -gt $key_free ]; then
		rm -f /zones/tmp_bu.$$.tgz
		cleanup
		fatal "Not enough free space for the backup on the USB key"
	fi

	mkdir -p $STANDBY_PATH
	# get list of old backups
	old_backup=`ls $STANDBY_PATH`
fi

fname=$destdir/backup-$(date +%Y-%m-%d-%H-%M-%S).tgz
echo "moving backup file to destination"
mv /zones/tmp_bu.$$.tgz $fname || fatal "writing to file $fname"

cleanup

sz=`ls -lh $fname | nawk '{print $5}'`
echo "The backup file (size $sz) is $fname"

[ "$destdir" == "/zones" ] && \
    echo "Copy or move this file to your backup medium."

if [ $dostandby == 1 ]; then
	# clean off old backups from key
	for i in $old_backup
	do
		rm -f $STANDBY_PATH/$i
	done

	[ -z "$mounted" ] && umount /mnt/usbkey
fi

exit 0
