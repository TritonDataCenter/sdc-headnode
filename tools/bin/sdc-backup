#!/usr/bin/bash

#
# Copyright (c) 2013, Joyent, Inc. All rights reserved.
# This backs up the SDC Manatee zone datasets and the USB config.
#

unset LD_LIBRARY_PATH
PATH=/usr/bin:/usr/sbin:/opt/smartdc/bin
export PATH

# This writes xtrace output and anything redirected to LOGFD to the log file.
LOGFD=4
exec 4>/tmp/backuplog.$$
# BASHSTYLED
export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
export BASH_XTRACEFD=${LOGFD}
set -o xtrace
set -o pipefail
set -o errexit

echo "logs at /tmp/backuplog.$$"

# readonly destdirectory=/zones/backups/$(uuid -v4)

readonly min_version=joyent_20140507T234920Z
readonly backup_key=/var/tmp/usbkey-backup
liveimage=

readonly dc_name=$(sysinfo | json '["Datacenter Name"]')
readonly timestamp=$(date -u "+%Y%m%dT%H%M%SZ")
readonly tmpdir=/var/tmp/backups.$$/
readonly destdirectory=/zones/backups/

readonly usb=${dc_name}-backup-usb-${timestamp}.img.tgz
readonly manatee=${dc_name}-backup-manatee-${timestamp}.gz
readonly imgs=${dc_name}-backup-local-iamges-${timestamp}.tar

readonly tmp_usb=${tmpdir}/${usb}
readonly tmp_manatee=${tmpdir}/${manatee}
readonly tmp_imgs=${tmpdir}/${imgs}

readonly dest_usb=${destdirectory}/${usb}
readonly dest_manatee=${destdirectory}/${manatee}
readonly dest_imgs=${destdirectory}/${imgs}

CLEANED=0

function usage
{
    # BASHSTYLED
    printf "usage: $(basename $0) \n" >/dev/stderr
    exit 1
}

function warn
{
    printf "Warning: %s\n" "$1" >/dev/stderr
}

function fatal
{
    printf "Error: %s\n" "$1" >/dev/stderr
    exit 1
}

function cleanup
{
    if [[ ${CLEANED} -eq 0 ]]; then
        rm -rf ${tmpdir}
        CLEANED=1
    fi
}

# mainline functions

# XXX - need to encode actual checks here.
function preflight
{
    local version=$(uname -v)
    if [[ ${version} < ${min_version} ]]; then
        fatal "Cannot back up, doesn't meet minimum required version."
    fi
}

# Shouldn't we have a real backup image here?
function mount_image
{
    pfexec mkdir -p ${backup_key}
    LOOPBACK=$(pfexec lofiadm -a ${IMG_TMP_DIR}/$$.${IMG})
    pfexec mount -f pcfs -o foldcase ${LOOPBACK}:c ${backup_key}
}

function umount_image
{
    if [[ -n ${LOOPBACK} ]]; then
        pfexec umount ${backup_key} || /usr/bin/true
        pfexec lofiadm -d ${LOOPBACK}
    fi
    sync; sync
    LOOPBACK=
}

function copy_platform
{
    echo -n "Copying in current platform..."
    liveimage=$(sysinfo | json '["Live Image"]')
    if [[ -d /usbkey/os/${liveimage} ]]; then
        mkdir -p ${backup_key}/os/${liveimage}
        cp -r /usbkey/os/${liveimage} \
            ${backup_key}/os
    else
        fatal "Can't find ${liveimage} in /usbkey/os"
    fi
    echo "Done"
}

function copy_image
{
    local image_uuid=$1
    local destdir=$2
    local is_origin=$3
    local origin_uuid=
    local manifest=
    local name=
    local file=
    local compression=


    manifest=${tmpdir}${image_uuid}.imgmanifest

    # XXX could fail if image has been deleted; zfs send & compress here.
    # or possibly always send & compress?
    sdc-imgadm get ${image_uuid} > ${manifest}

    compression=$(json -f ${manifest} files[0].compression)
    case ${compression} in
        gzip) compression=".gz" ;;
        bzip2) compression=".bz2" ;;
        none) compression="" ;;
        *) fatal "Unknown compression for image ${manifest}: ${compression}"
    esac

    name=$(json -f ${manifest} name)-zfs-$(json -f ${manifest} version)

    # XXX - do we already have that one? stop now.
    if [[ -f ${destdir}/${name}.zfs${compression} ]]; then
        echo "Skipping ${name} - already present"
    else
        echo "Writing ${name} to backup-usbkey"
        cp ${manifest} ${destdir}/${name}.imgmanifest
        sdc-imgadm get-file -o ${destdir}/${name}.zfs${compression} \
          ${image_uuid}

        if [[ -n ${is_origin} ]]; then
            echo ${name} >> ${destdir}/img_dependencies
        fi

        origin_uuid=$(json -f ${manifest} origin)
        if [[ -n ${origin_uuid} ]]; then
            copy_image ${origin_uuid} ${destdir} "yes"
        fi
    fi
}

function copy_images
{
    echo -n "Copying current zone images..."
    local core_zones=
    local destdir=
    local image_uuid=

    core_zones=$(vmadm lookup tags.smartdc_type=core state=running)
    destdir=${backup_key}/datasets
    mkdir -p ${destdir}

    if [ ! -d ${tmpdir} ]; then
        mkdir -p ${tmpdir}
    fi
    # actual zones
    for zone in ${core_zones}; do
        image_uuid=$(vmadm get ${zone} | json image_uuid)
        copy_image ${image_uuid} ${destdir}
    done
    echo "Done."
}

function backup_payloads
{
    local core_zones=
    local destdir=
    local name=

    echo -n "Backing up zone creation payloads..."

    core_zones=$(vmadm lookup tags.smartdc_type=core state=running)

    destdir=${tmpdir}/payloads
    mkdir -p ${destdir}

    # XXX - only `vmadm get` atm.
    for zone in ${core_zones}; do
        vmadm get ${zone} > ${destdir}/${zone}.json
        process_payload ${destdir}/${zone}.json
    done

    mkdir -p ${backup_key}/payloads
    tar zcf ${backup_key}/payloads/payloads.tgz -C ${destdir} *.json

    echo "Done."
}

function add_manifests
{
    echo -n "Creating usbkey manifests..."
    # build manifest of USB files + move in boot_archive manifest
    rm -f ${backup_key}/usb_key.manifest || true
    (cd ${backup_key} \
        && find . -type f -exec openssl dgst -md5 {} \; | awk '{print $NF}') \
        > ${backup_key}/usb_key.manifest

    rm -f ${backup_key}/boot_archive.manifest || true

    # BASHSTYLED
    cp ${backup_key}/os/${liveimage}/platform/i86pc/amd64/boot_archive.manifest \
        ${backup_key}/boot_archive.manifest

    chmod 444 ${backup_key}/*.manifest
    echo "Done."
}

function backup_usbkey
{
    local top_level=

    echo "Creating restoration usbkey..."
    pfexec mkdir -p ${backup_key}
    # mount_image
    /usbkey/scripts/mount-usb.sh
    local src=/mnt/usbkey

    # current top-level contents of usbkey, and inclusion in backup
    # application.json       n - in SAPI (or grab from SAPI)
    # banner                 y
    # boot                   n - use template image
    # boot_archive.manifest  n - modify?
    # config                 y
    # config.inc             y
    # datasets               n - get current ones from IMGAPI
    # default                y
    # devtools               y
    # dos                    y
    # eula                   y
    # firmware               y
    # manifests              n - SAPI information
    # os                     y? update platform? is/should this be current?
    # private                y
    # scripts                y
    # sdcadm-install.sh      y
    # services               n - SAPI information
    # tools                  y
    # tools-man              y
    # tools-modules.tar      y
    # ur-scripts             y
    # usb_key.manifest       n - regenerate
    # version                y - modify?
    # zones                  ?? - maybe? might need dataset updates? depends
    #                             on how we structure the restoration.

    top_level=$(ls -1 ${src} \
        | grep -v application.json \
        | grep -v boot_archive.manifest \
        | grep -v datasets \
        | grep -v manifests \
        | grep -v os \
        | grep -v services \
        | grep -v usb_key.manifest)

    for item in ${top_level}; do
        cp -r ${src}/${item} ${backup_key}/${item}
    done

    copy_platform
    copy_images
    add_manifests

    # umount_image
    umount /mnt/usbkey
    echo "Done."
}

local_manatee=$(vmadm lookup state=running tags.smartdc_role=manatee | tail -1)

function manatee_stat
{
    # manatee-stat exists in different places depending on the manatee version,
    # and therefore on the stage of the upgrade; find it explicitly.
    local m_stat=
    local result=
    if [[ -f /zones/${local_manatee}/root/opt/smartdc/manatee/bin/manatee-stat ]]; then
        m_stat="/opt/smartdc/manatee/bin/manatee-stat -p \$ZK_IPS"
    elif [[ -f /zones/${local_manatee}/root/opt/smartdc/manatee/node_modules/manatee/bin/manatee-stat ]]; then
        m_stat="/opt/smartdc/manatee/node_modules/manatee/bin/manatee-stat -p \$ZK_IPS"
    elif [[ -f /zones/${local_manatee}/root/opt/smartdc/manatee/node_modules/.bin/manatee-stat ]]; then
        m_stat="/opt/smartdc/manatee/node_modules/.bin/manatee-stat -p \$ZK_IPS"
    else
        fatal "Can't find manatee-stat."
    fi
    if [[ ! -f /zones/${local_manatee}/root/opt/smartdc/etc/zk_ips.sh ]]; then
        # race condition on the creation of zk_ips when the local manatee
        # is reprovisioning/rebooting.
        result="{}"
    else
        result=$(zlogin ${local_manatee} "source /opt/smartdc/etc/zk_ips.sh; ${m_stat}");
    fi
    echo ${result}
}


function find_sync_manatee
{
    manatee_instance=$(manatee_stat | json -Ha sdc.sync.zoneId)
    if [[ -z ${manatee_instance} ]]; then
        echo "Can't find sync manatee"
        find_primary_manatee
    fi
    manatee_server=$(sdc-vmapi /vms/${manatee_instance} | json -Ha server_uuid)
    if [[ $? != 0 || -z ${manatee_server} ]]; then
        echo "Can't find server for sync manatee: ${manatee_instance}"
        find_primary_manatee
    fi

}

function find_primary_manatee
{
    manatee_instance=$(manatee_stat | json -Ha sdc.primary.zoneId)
    if [[ -z ${manatee_instance} ]]; then
        echo ""
        fatal "Can't find primary manatee"
    fi
    manatee_server=$(sdc-vmapi /vms/${manatee_instance} | json -Ha server_uuid)
    if [[ $? != 0 || -z ${manatee_server} ]]; then
        echo ""
        fatal "Can't find server for primary manatee: ${manatee_instance}"
    fi
}

function backup_manatee
{
    # In case of not finding the sync manatee, it will automatically try to
    # find primary manatee or will fail
    find_sync_manatee
    echo "Backing up Manatee ..."
    echo "Creating backup for manatee instance ${manatee_instance} \
on node ${manatee_server}"

    sdc-oneachnode -n ${manatee_server} \
      "mkdir -p ${tmpdir}"

    # TODO: What is a good value for the exec timeout of a manatee backup?
    sdc-oneachnode -n ${manatee_server} -T 600 \
    "/zones/${manatee_instance}/root/opt/smartdc/manatee/bin/manatee-backup.sh \
        ${tmpdir}/manatee.zfs;"

    # This is awesomely slow: 17GB => 14 mins. Give it an hour to complete?
    echo "Compressing backup on node ${manatee_server}"
    sdc-oneachnode -n ${manatee_server} -T 3600 \
    "/usr/bin/gzip -c ${tmpdir}/manatee.zfs > ${tmp_manatee}"

    # If our HN is also $manatee_server, we don't need to copy anything else:
    if [[ ! -f ${tmp_manatee} ]]; then
        echo "Copying manatee backup from node ${manatee_server}"
        sdc-oneachnode -n ${manatee_server} -p ${tmp_manatee} -T 600
        # The file will be copied to $(pwd) as "${manatee_server}". We want it
        # moved to our ${tmp_manatee} location
        mv $(pwd)/${manatee_server} ${tmp_manatee}
    fi

    # Finally, remove the .zfs file:
    sdc-oneachnode -n ${manatee_server} "rm ${tmpdir}/manatee.zfs"

    echo "Done."
}

function backup_local_images
{
    echo -n "Backing up local images..."
    local image_list=
    local destdir=${tmpdir}/local_images

    mkdir -p ${destdir}

    image_list=$(imgadm list -o uuid)
    for image in image_list; do
        copy_image ${destdir}
    done

    # extraneous file created for backup-usbkey
    rm ${destdir}/img_dependencies

    # tar it all up.
    tar cf ${tmp_imgs} -C ${destdir} .
    echo "Done."
}

function process_payload
{
    local orig=$0
    local tmp0=${orig}.tmp0
    local tmp1=${orig}.tmp1
    touch ${tmp0}
    touch ${tmp1}

    # XXX - what needs doing TBD
    # json -f ${orig}

    rm *.tmp{0,1}
}

function wrap_up
{
    mkdir -p ${destdirectory}
    mv ${tmp_usb} ${dest_usb}
    mv ${tmp_manatee} ${dest_manatee}
    mv ${tmp_imgs} ${dest_images}
    echo "Backup complete:"
    echo "  backup usbkey image: ${dest_usb}"
    echo "       manatee backup: ${dest_manatee}"
    echo "   local image backup: ${dest_imgs}"
    echo "Copy or move these files to the backup medium"
}

#
# Mainline
#

if [[ $(sysinfo | json '["Boot Parameters"].headnode') != "true" ]]
then
    fatal "backup can only be run from the headnode"
fi

mkdir -p ${destdirectory} || fatal "unable to create backup directory $destdir"

trap cleanup EXIT

preflight

backup_usbkey
backup_manatee
backup_local_images
wrap_up

cleanup

exit 0
