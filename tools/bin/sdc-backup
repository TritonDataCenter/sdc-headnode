#!/usr/bin/bash

#
# Copyright (c) 2014, Joyent, Inc. All rights reserved.
# This backs up the SDC Manatee zone datasets and the USB config.
#

unset LD_LIBRARY_PATH
PATH=/usr/bin:/usr/sbin:/opt/smartdc/bin
export PATH

# This writes xtrace output and anything redirected to LOGFD to the log file.
LOGFD=4
exec 4>/tmp/backuplog.$$
# BASHSTYLED
export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
export BASH_XTRACEFD=${LOGFD}
set -o xtrace
set -o pipefail
set -o errexit

echo "logs at /tmp/backuplog.$$"

readonly min_version=joyent_20140507T234920Z
liveimage=

readonly dc_name=$(sysinfo | json '["Datacenter Name"]')
readonly timestamp=$(date -u "+%Y%m%dT%H%M%SZ")
readonly mnt_dir=/mnt/tmp
readonly tmpdir=/var/tmp/backups.$$
readonly destdirectory=/zones/backups

readonly template_image=/opt/smartdc/share/4gb.img.tgz
readonly usb=${dc_name}-backup-usb-${timestamp}.img
readonly manatee=${dc_name}-backup-manatee-${timestamp}.gz
readonly imgs=${dc_name}-backup-local-iamges-${timestamp}.tar

readonly tmp_usb=${tmpdir}/${usb}
readonly tmp_manatee=${tmpdir}/${manatee}
readonly tmp_imgs=${tmpdir}/${imgs}

readonly dest_usb=${destdirectory}/${usb}
readonly dest_manatee=${destdirectory}/${manatee}
readonly dest_imgs=${destdirectory}/${imgs}

CLEANED=0

function usage
{
    printf "usage: $(basename $0) \n" >/dev/stderr
    exit 1
}

function warn
{
    printf "Warning: %s\n" "$1" >/dev/stderr
}

function fatal
{
    printf "Error: %s\n" "$1" >/dev/stderr
    echo ""
    echo "*** BACKUP FAILED - see logs at ${/tmp/backuplog.$$} ***"
    echo ""
    exit 1
}

function cleanup
{
    local USB_MOUNTED
    if [[ ${CLEANED} -eq 0 ]]; then
        rm -rf ${tmpdir}
        CLEANED=1
    fi
    umount_backup_image
    USBKEY_MOUNTED=$(mount | grep '/mnt/usbkey' || true)
    [[ -n ${USBKEY_MOUNTED} ]] && umount /mnt/usbkey
}

# mainline functions

# XXX - need to encode actual checks here.
function preflight
{
    local version=$(uname -v)
    if [[ ${version} < ${min_version} ]]; then
        fatal "Cannot back up, doesn't meet minimum required version."
    fi

    mkdir -p ${tmpdir}
}

# Shouldn't we have a real backup image here?
function mount_backup_image
{
    local OUTPUT
    OUTPUT=$(gtar -C ${tmpdir} -xzvf ${template_image})
    mv ${tmpdir}/${OUTPUT} ${tmp_usb}
    mkdir -p ${mnt_dir}

    LOOPBACK=$(pfexec lofiadm -a ${tmp_usb})
    # XXX - /usbkey/scripts uses noatime here?
    pfexec mount -f pcfs -o foldcase ${LOOPBACK}:c ${mnt_dir}
}

function umount_backup_image
{
    if [[ -n ${LOOPBACK} ]]; then
        pfexec umount ${mnt_dir} || /usr/bin/true
        pfexec lofiadm -d ${LOOPBACK}
    fi
    sync; sync
    LOOPBACK=
}

function copy_platform
{
    echo -n "Copying in current platform..."
    liveimage=$(sysinfo | json '["Live Image"]')
    if [[ -d /usbkey/os/${liveimage} ]]; then
        mkdir -p ${mnt_dir}/os/${liveimage}
        cp -r /usbkey/os/${liveimage} \
            ${mnt_dir}/os
    else
        fatal "Can't find ${liveimage} in /usbkey/os"
    fi
    echo "Done"
}

function copy_image
{
    local image_uuid=$1
    local destdir=$2
    local is_origin=$3
    local origin_uuid=
    local manifest=
    local name=
    local file=
    local compression=


    manifest=${tmpdir}/${image_uuid}.imgmanifest

    # XXX could fail if image has been deleted; zfs send & compress here.
    # or possibly always send & compress?
    sdc-imgadm get ${image_uuid} > ${manifest}

    compression=$(json -f ${manifest} files[0].compression)
    case ${compression} in
        gzip) compression=".gz" ;;
        bzip2) compression=".bz2" ;;
        none) compression="" ;;
        *) fatal "Unknown compression for image ${manifest}: ${compression}"
    esac

    name=$(json -f ${manifest} name)-zfs-$(json -f ${manifest} version)

    if [[ -f ${destdir}/${name}.zfs${compression} ]]; then
        echo "Skipping ${name} - already present"
    else
        echo "Writing ${name} to ${destdir}"
        cp ${manifest} ${destdir}/${name}.imgmanifest
        sdc-imgadm get-file -q -o ${destdir}/${name}.zfs${compression} \
          ${image_uuid}

        if [[ -n ${is_origin} ]]; then
            echo ${name} >> ${destdir}/img_dependencies
        fi

        origin_uuid=$(json -f ${manifest} origin)
        if [[ -n ${origin_uuid} ]]; then
            copy_image ${origin_uuid} ${destdir} "yes"
        fi
    fi
}

function copy_images
{
    echo -n "Copying current zone images..."
    local core_zones=
    local destdir=
    local image_uuid=

    core_zones=$(vmadm lookup tags.smartdc_type=core state=running)
    destdir=${mnt_dir}/datasets
    mkdir -p ${destdir}

    # actual zones
    for zone in ${core_zones}; do
        image_uuid=$(vmadm get ${zone} | json image_uuid)
        copy_image ${image_uuid} ${destdir}
    done
    echo "Done."
}

function backup_payloads
{
    local core_zones=
    local destdir=
    local name=

    echo -n "Backing up zone creation payloads..."

    core_zones=$(vmadm lookup tags.smartdc_type=core state=running)

    destdir=${tmpdir}/payloads
    mkdir -p ${destdir}

    # XXX - only `vmadm get` atm.
    for zone in ${core_zones}; do
        vmadm get ${zone} > ${destdir}/${zone}.json
        process_payload ${destdir}/${zone}.json
    done

    mkdir -p ${tmp_usb}/payloads
    tar zcf ${tmp_usb}/payloads/payloads.tgz -C ${destdir} *.json

    echo "Done."
}

function add_manifests
{
    echo -n "Creating usbkey manifests..."
    # build manifest of USB files + move in boot_archive manifest
    rm -f ${mnt_dir}/usb_key.manifest || true
    (cd ${mnt_dir} \
        && find . -type f -exec openssl dgst -md5 {} \; | awk '{print $NF}') \
        > ${mnt_dir}/usb_key.manifest

    rm -f ${mnt_dir}/boot_archive.manifest || true

    # BASHSTYLED
    cp ${mnt_dir}/os/${liveimage}/platform/i86pc/amd64/boot_archive.manifest \
        ${mnt_dir}/boot_archive.manifest

    chmod 444 ${mnt_dir}/*.manifest
    echo "Done."
}

function dump_sapi_information
{
    # XXX - may need post-processing to:
    #   a) insert into restore-key/services
    #   b) inject into sapi some other way
    # Backup sapi applications:
    local dest=${mnt_dir}/sapi_dump
    mkdir -p ${dest}
    sdc-sapi --no-headers /applications > ${dest}/sapi-applications.json
    sdc-sapi --no-headers /services > ${dest}/sapi-services.json
    sdc-sapi --no-headers /instances > ${dest}/sapi-instances.json
    sdc-sapi --no-headers /manifests > ${dest}/sapi-manifests.json
}

function dump_vmapi_vms
{
    local dest=${mnt_dir}/vmapi_dump
    mkdir -p ${dest}
    local num_machines=$(sdc-vmapi /vms -X HEAD | \
      grep x-joyent-resource-count | awk {'print $2'})
    # Fetching machines in groups of 1000 makes everything go OK. Attempts
    # to fetch everything at once result into errors from VMAPI
    local completed=0
    local following=1000
    while [[ ${completed} -lt ${num_machines} ]]; do
      sdc-vmapi --no-headers /vms?offset=${completed}\&limit=1000 > \
        ${dest}/vmapi-vms-${completed}-${following}.json
      let completed+=1000
      let following+=1000
    done
}

function dump_cnapi_cns
{
    # XXX: This assumes we will not need to paginate b/c we don't have more
    # than 1000 CNs. Additionally, CNAPI didn't provide a way to retrieve
    # the total number of CNs using HTTP HEAD method, like VMAPI does. We
    # should consider adding it.
    local dest=${mnt_dir}/cnapi_dump
    mkdir -p ${dest}
    sdc-cnapi /servers?extras=sysinfo,capacity > ${dest}/cnapi.json
}

# XXX - don't change anything except the title.
# XXX - even that might not be necessary.
function setup_grub
{
    cp -r /mnt/usbkey/boot/grub/bin ${mnt_dir}/boot/grub/bin

    sed -e "s/^Title Live 64-bit/Title Live 64-bit (${dc_name} disaster recovery ${timestamp})/" \
        /mnt/usbkey/boot/grub/menu.lst > ${mnt_dir}/boot/grub/menu.lst
}

function backup_usbkey
{
    local top_level=
    local USBKEY_MOUNTED=

    echo "Creating restoration usbkey..."
    # pfexec mkdir -p ${tmp_usb}
    mount_backup_image
    USBKEY_MOUNTED=$(mount | grep '/mnt/usbkey' || true)
    [[ -z ${USBKEY_MOUNTED} ]] && /usbkey/scripts/mount-usb.sh
    local src=/mnt/usbkey

    # current top-level contents of usbkey, and inclusion in backup
    # application.json       n - in SAPI (or grab from SAPI)
    # banner                 y
    # boot                   n - use template image
    # boot_archive.manifest  n - modify? regenerate?
    # config                 y
    # config.inc             y
    # datasets               n - get current ones from IMGAPI
    # default                y
    # devtools               y
    # dos                    y
    # eula                   y
    # firmware               y
    # manifests              n - SAPI information
    # os                     y? update platform? is/should this be current?
    # private                y
    # scripts                y
    # sdcadm-install.sh      y
    # services               n - SAPI information
    # tools                  y
    # tools-man              y
    # tools-modules.tar      y
    # ur-scripts             y
    # usb_key.manifest       n - regenerate
    # version                y - modify?
    # zones                  ?? - maybe? might need dataset updates? depends
    #                             on how we structure the restoration.

    top_level=$(ls -1 ${src} \
        | grep -v ^application.json \
        | grep -v ^boot_archive.manifest \
        | grep -v ^datasets \
        | grep -v ^manifests \
        | grep -v ^os \
        | grep -v ^services \
        | grep -v ^usb_key.manifest)

    for item in ${top_level}; do
        cp -r ${src}/${item} ${mnt_dir}/${item}
    done

    copy_platform
    setup_grub
    copy_images
    add_manifests
    dump_sapi_information
    dump_vmapi_vms
    dump_cnapi_cns

    # XXX - flag. Is this a good place for it; after restore we want things to
    # behave "normally" on the next reboot. But that should also be a manual
    # step and/or a "clear" tool.
    touch ${mnt_dir}/RESTORE_IMAGE

    umount_backup_image
    umount ${src}

    echo "Done."
}

local_manatee=$(vmadm lookup state=running tags.smartdc_role=manatee | tail -1)

function manatee_stat
{
    # manatee-stat exists in different places depending on the manatee version,
    # and therefore on the stage of the upgrade; find it explicitly.
    local m_stat=
    local result=
    if [[ -f /zones/${local_manatee}/root/opt/smartdc/manatee/bin/manatee-stat ]]; then
        m_stat="/opt/smartdc/manatee/bin/manatee-stat -p \$ZK_IPS"
    elif [[ -f /zones/${local_manatee}/root/opt/smartdc/manatee/node_modules/manatee/bin/manatee-stat ]]; then
        m_stat="/opt/smartdc/manatee/node_modules/manatee/bin/manatee-stat -p \$ZK_IPS"
    elif [[ -f /zones/${local_manatee}/root/opt/smartdc/manatee/node_modules/.bin/manatee-stat ]]; then
        m_stat="/opt/smartdc/manatee/node_modules/.bin/manatee-stat -p \$ZK_IPS"
    else
        fatal "Can't find manatee-stat."
    fi
    if [[ ! -f /zones/${local_manatee}/root/opt/smartdc/etc/zk_ips.sh ]]; then
        # race condition on the creation of zk_ips when the local manatee
        # is reprovisioning/rebooting.
        result="{}"
    else
        result=$(zlogin ${local_manatee} "source /opt/smartdc/etc/zk_ips.sh; ${m_stat}");
    fi
    echo ${result}
}


function find_sync_manatee
{
    manatee_instance=$(manatee_stat | json -Ha sdc.sync.zoneId)
    if [[ -z ${manatee_instance} ]]; then
        echo "Can't find sync manatee"
        find_primary_manatee
    fi
    manatee_server=$(sdc-vmapi /vms/${manatee_instance} | json -Ha server_uuid)
    if [[ $? != 0 || -z ${manatee_server} ]]; then
        echo "Can't find server for sync manatee: ${manatee_instance}"
        find_primary_manatee
    fi

}

function find_primary_manatee
{
    manatee_instance=$(manatee_stat | json -Ha sdc.primary.zoneId)
    if [[ -z ${manatee_instance} ]]; then
        echo ""
        fatal "Can't find primary manatee"
    fi
    manatee_server=$(sdc-vmapi /vms/${manatee_instance} | json -Ha server_uuid)
    if [[ $? != 0 || -z ${manatee_server} ]]; then
        echo ""
        fatal "Can't find server for primary manatee: ${manatee_instance}"
    fi
}

function backup_manatee
{
    # In case of not finding the sync manatee, it will automatically try to
    # find primary manatee or will fail
    find_sync_manatee
    echo "Backing up Manatee ..."
    echo "Creating backup for manatee instance ${manatee_instance} \
on node ${manatee_server}"

    sdc-oneachnode -n ${manatee_server} \
      "mkdir -p ${tmpdir}"

    # TODO: What is a good value for the exec timeout of a manatee backup?
    sdc-oneachnode -n ${manatee_server} -T 600 \
    "/zones/${manatee_instance}/root/opt/smartdc/manatee/bin/manatee-backup.sh \
        ${tmpdir}/manatee.zfs;"

    # This is awesomely slow: 17GB => 14 mins. Give it an hour to complete?
    # XXX - how much space does this save us?
    # YYY - It compresses 17GB into 3.5GB for my tests.
    echo "Compressing backup on node ${manatee_server}"
    sdc-oneachnode -n ${manatee_server} -T 3600 \
    "/usr/bin/gzip -c ${tmpdir}/manatee.zfs > ${tmp_manatee}"

    # If our HN is also $manatee_server, we don't need to copy anything else:
    if [[ ! -f ${tmp_manatee} ]]; then
        echo "Copying manatee backup from node ${manatee_server}"
        sdc-oneachnode -n ${manatee_server} -p ${tmp_manatee} -T 600
        # The file will be copied to $(pwd) as "${manatee_server}". We want it
        # moved to our ${tmp_manatee} location
        mv $(pwd)/${manatee_server} ${tmp_manatee}
    fi

    # Finally, remove the .zfs file:
    sdc-oneachnode -n ${manatee_server} "rm ${tmpdir}/manatee.zfs"

    echo "Done."
}

function backup_local_images
{
    echo -n "Backing up local images..."
    local image_list=
    local destdir=${tmpdir}/local_images

    mkdir -p ${destdir}

    image_list=$(sdc-imgadm list -H -o uuid)
    for image in ${image_list}; do
        copy_image ${image} ${destdir}
    done

    # extraneous file created for backup-usbkey
    if [ -d ${destdir}/img_dependencies ]; then
        rm ${destdir}/img_dependencies
    fi

    # tar it all up.
    tar cf ${tmp_imgs} -C ${destdir} .
    echo "Done."
}

function process_payload
{
    local orig=$0
    local tmp0=${orig}.tmp0
    local tmp1=${orig}.tmp1
    touch ${tmp0}
    touch ${tmp1}

    # XXX - what needs doing TBD
    # json -f ${orig}

    rm *.tmp{0,1}
}

function wrap_up
{
    mkdir -p ${destdirectory}
    gzip -c ${tmp_usb} > ${dest_usb}.gz
    mv ${tmp_manatee} ${dest_manatee}
    mv ${tmp_imgs} ${dest_imgs}
    echo "Backup complete:"
    echo "  backup usbkey image: ${dest_usb}.gz"
    echo "       manatee backup: ${dest_manatee}"
    echo "   local image backup: ${dest_imgs}"
    echo "*****************************************"
    echo "* COPY OR MOVE THESE FILES OFF SITE NOW *"
    echo "*****************************************"
}

#
# Mainline
#

if [[ $(sysinfo | json '["Boot Parameters"].headnode') != "true" ]]
then
    fatal "backup can only be run from the headnode"
fi

trap cleanup EXIT

preflight

backup_usbkey
backup_manatee
backup_local_images
wrap_up

cleanup

exit 0
