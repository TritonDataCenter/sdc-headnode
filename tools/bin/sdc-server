#!/usr/node/bin/node
/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

/*
 * Copyright (c) 2019, Joyent, Inc.
 */

//
//
// Summary:
//
//  This tool is used to manage servers (HN or CN) in SDC.
//

var assert = require('assert-plus');
// TODO: Should convert over to vasync (to avoid platform node_modules, and
//       vasync is preferred)
var async = require('/usr/node/node_modules/async');
var dashdash = require('dashdash');
var exec = require('child_process').exec;
var readline = require('readline');
var netconfig = require('triton-netconfig');
var util = require('util');
var vasync = require('vasync');

var SDC_MODULES = '/opt/smartdc/node_modules';
var restifyClients = require(SDC_MODULES +
                             '/sdc-clients/node_modules/restify-clients');
var sprintf = require('/usr/node/node_modules/sprintf').sprintf;
var sdcClients = require(SDC_MODULES + '/sdc-clients');

// global
var sdc_config;

function usage()
{
    /* BEGIN JSSTYLED */
    console.log([
        '',
        'Usage:',
        '        /opt/smartdc/bin/sdc-server <sub-command> [options]',
        '',
        'Sub-commands:',
        '',
        '    delete [-f] <uuid>                    - remove all CNAPI information about',
        '                                            this server',
        '    jobs <uuid>                           - list all jobs for this server',
        '    list                                  - list all servers in this DC',
        '    lookup [-h1jHc] [field=val ...]       - lookup servers matching given fields',
        '    ips <uuid>                            - output the IPs for this server',
        '    nics <uuid>                           - output the nics for this server',
        '    admin-ip <uuid>                       - output the admin IP address for this server',
        '    setup [-s] <uuid> [params]            - setup a new server in this DC',
        '    sysinfo <uuid>                        - output the latest `sysinfo` from',
        '                                            the server',
        '    update-nictags [-s] <uuid> [params]   - update nic tags for this server',
        '    replace-nictags [-s] <uuid> [params]  - set nic tags for this server',
        '    delete-nictags [-s] <uuid> [params]   - delete nic tags from this server',
        ''
    ].join('\n'));
    /* END JSSTYLED */
}


function setup_usage()
{
    /* BEGIN JSSTYLED */
    console.log([
        '',
        'Usage:',
        '        /opt/smartdc/bin/sdc-server setup [-s] <uuid> [param=value ... ]',
        '',
        'Possible params (all of them optional):',
        '',
        '    hostname=<string>                                 - Server hostname',
        '    spares=<0-N>                                      - disk spares',
        '    cache=<true|false>                                - disk cache',
        '    layout=<single|mirror|raidz1|raidz2|raidz3>       - disk layout',
        '    postsetup_script=<string>                         - script to be run right after server setup',
        '    (external|admin)_nic=<JSON object>                - nic tags for the server',
        ''
    ].join('\n'));
    /* END JSSTYLED */
}

function isUUID(str) {
    var re = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    if (!str) {
        return false;
    }
    if (str.length === 36 && str.match(re)) {
        return true;
    } else {
        return false;
    }
}

// TODO should pull this out to separate library. See OS-2065.

function getConfig(callback)
{
    var cmd = '/bin/bash /lib/sdc/config.sh -json';

    if (sdc_config) {
        callback();
        return;
    }

    exec(cmd, function (err, stdout, stderr) {
        if (!err) {
            try {
                sdc_config = JSON.parse(stdout);
            } catch (e) {
                err = e;
            }
        } else {
            err.stdout = stdout;
            err.stderr = stderr;
        }
        callback(err);
    });
}

// returns an sdc-client or restify handle for the API after finding the API
// endpoint for you.
function createClient(api, callback) {
    var handle;

    switch (api.toUpperCase()) {
        case 'CNAPI':
            handle = new sdcClients.CNAPI({
                url: sdc_config.cnapi_client_url,
                agent: false
            });
            callback(null, handle);
            return;
        case 'NAPI':
            handle = new sdcClients.NAPI({
                url: sdc_config.napi_client_url,
                agent: false
            });
            callback(null, handle);
            return;
        case 'WFAPI':
            handle = restifyClients.createJsonClient({
                url: 'http://' + sdc_config.workflow_domain,
                agent: false
            });
            callback(null, handle);
            return;
        default:
            callback(new Error('Unknown API: ' + api));
            return;
    }
}

function _getServer(server_uuid, callback)
{
    var cnapi;
    var server;

    async.series([
        function (cb) {
            createClient('CNAPI', function (err, handle) {
                if (!err) {
                    cnapi = handle;
                } else {
                    err.api = 'CNAPI';
                }
                cb(err);
            });
        }, function (cb) {
            cnapi.getServer(server_uuid, function (err, s) {
                if (err) {
                    err.api = 'CNAPI';
                } else {
                    server = s;
                }
                cb(err);
            });
        }
    ], function (err) {
        callback(err, server);
    });
}

function getNics(server_uuid, params, callback)
{
    var nics;
    var napi;

    async.series([
        function (cb) {
            createClient('NAPI', function (err, handle) {
                if (!err) {
                    napi = handle;
                } else {
                    err.api = 'NAPI';
                }
                cb(err);
            });
        }, function (cb) {
            var listParams = {
                belongs_to_uuid: server_uuid
            };

            for (var p in params) {
                listParams[p] = params[p];
            }

            napi.listNics(listParams, function (err, n) {
                if (err) {
                    err.api = 'NAPI';
                } else {
                    nics = n;
                }
                cb(err);
            });
        }
    ], function (err) {
        if (err) {
            return callback(err);
        }

        return callback(null, nics);
    });
}

function outputServerData(servers, callback)
{
    /*
     * Since workflow orders jobs in descending order based on created_at and
     * we're passing in the name 'server-setup*' we'll get the newest one first.
     * That's the only one we care about here, so we limit=1.
     */
    var getJobOpts = {
        limit: 1,
        name: 'server-setup*'
    };

    console.log(sprintf('%-20s %-36s %7s %8s  %8s  %7s  %-15s',
        'HOSTNAME', 'UUID', 'VERSION', 'SETUP', 'STATUS', 'RAM', 'ADMIN_IP'));

    servers.forEach(function (s) {
        var admin_ip;
        var sdc_version;
        var setup_state = s.setup;

        // Eventually this will be a first-class property of a CN
        sdc_version = s.sysinfo['SDC Version'];
        if (!sdc_version) {
            sdc_version = '6.x';
        }

        admin_ip = netconfig.adminIpFromSysinfo(s['sysinfo']);
        if (!admin_ip) {
            admin_ip = '-';
        }

        function outputLine() {
            console.log(sprintf('%-20s %36s %7s %8s  %8s  %7d  %-15s',
                s.hostname,
                s.uuid,
                sdc_version,
                (typeof (setup_state) === 'undefined' ? 'unknown': setup_state),
                s.status,
                s.ram,
                admin_ip));
        }

        if (s.setup === false && s.setting_up) {
            // setup job is currently running
            setup_state = 'running';

            getJobs(s.uuid, getJobOpts, function (err, jobs) {
                var job;

                if (err) {
                    callback(err);
                    return;
                }

                if (jobs.length === 1) {
                    job = jobs[0];

                    // our query had name=server-setup* so we shouldn't see any
                    // other name.
                    assert.ok(job.name.match(/^server-setup/),
                        'got incorrect results from workflow: ' + job.name);

                    setup_state = job.execution;
                } else {
                    console.error('WARNING: unable to find setup job for '
                        + s.uuid);
                }

                outputLine();
            });

        } else {
            outputLine();
        }
    });
    callback();
}

function outputServerList(callback)
{
    var cnapi;
    var servers;

    async.series([
        function (cb) {
            createClient('CNAPI', function (err, handle) {
                if (!err) {
                    cnapi = handle;
                } else {
                    err.api = 'CNAPI';
                }
                cb(err);
            });
        }, function (cb) {
            // grab all the servers
            cnapi.listServers({extras: 'sysinfo'}, function (err, s) {
                if (err) {
                    err.api = 'CNAPI';
                } else {
                    servers = s;
                }
                cb(err);
            });
        }
    ], function (err) {
        if (err) {
            callback(err);
            return;
        }
        outputServerData(servers, callback);
    });
}

/**
 * Take CLI input args of the following forms and transform
 * to an array of filter objects (type, key, value, negated).
 *
 *      FIELD=VALUE               exact string match
 *      FIELD=true|false          boolean match
 *      FIELD!=...                negated string or boolean match
 *      FIELD=~REGEX              regular expression match
 *      FIELD!~REGEX              negated regular expression match
 *      FIELD>NUMBER              numeric comparisons
 *      FIELD<NUMBER
 *      FIELD>=NUMBER
 *      FIELD<=NUMBER
 */
function filtersFromArgs(args) {
    assert.arrayOfString(args, 'args');

    // JSSTYLED
    var filterRe = /^([ \w_\.-]+)(<=|>=|<|>|!=|=~|!~|=)(.+)$/;

    var filters = [];
    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        var parsed = filterRe.exec(arg);
        if (!parsed) {
            throw new Error(util.format('invalid filter: "%s" ' +
                '(see "Filters" in "sdc-server lookup -h")', arg));
        }

        var filter = {
            key: parsed[1]
        };
        var op = parsed[2];
        var val = parsed[3];
        switch (op) {
        case '>':
        case '>=':
        case '<':
        case '<=':
            filter.negated = false;
            if (isNaN(Number(val))) {
                throw new Error(util.format(
                    'invalid filter: "%s" (value must be a number for "%s")',
                    arg, val, op));
            } else {
                filter.type = 'number';
                filter.op = op;
                filter.value = Number(val);
            }
            break;
        case '=':
            filter.negated = false;
            if (val === 'true') {
                filter.type = 'bool';
                filter.value = true;
            } else if (val === 'false') {
                filter.type = 'bool';
                filter.value = false;
            } else {
                filter.type = 'string';
                filter.value = val;
            }
            break;
        case '!=':
            filter.negated = true;
            if (val === 'true') {
                filter.type = 'bool';
                filter.value = true;
            } else if (val === 'false') {
                filter.type = 'bool';
                filter.value = false;
            } else {
                filter.type = 'string';
                filter.value = val;
            }
            break;
        case '=~':
            filter.negated = false;
            filter.type = 'regexp';
            filter.value = new RegExp(val);
            break;
        case '!~':
            filter.negated = true;
            filter.type = 'regexp';
            filter.value = new RegExp(val);
            break;
        default:
            throw new Error('unknown filter op: ' + op);
        }
        filters.push(filter);
    }
    return filters;
}

/*
 * lookup the property "str" (given in dot-notation) in the object "obj".
 * "delim" is optional and may be set to any delimiter (defaults to dot: ".")
 *
 * Borrowed from <https://github.com/trentm/node-tabula>.
 */
function dottedLookup(obj, str, delim) {
    if (delim === undefined)
        delim = '.';
    var o = obj;
    var segments = str.split(delim);
    var s = [];
    for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        s.push(segment);
        if (o === null || o === undefined || !o.hasOwnProperty(segment)) {
            throw new Error('no property ' + s.join(delim) + ' found');
        }
        o = o[segment];
    }
    return o;
}

/*
 * sdc-server lookup ...
 *
 * TODO:
 * - "One other thing that'd be handy but not sure if it belongs here would be
 *   to find servers given a list of VM uuids."   This could be done via
 *   CNAPI server.vms (using extras=vms to get that info).
 * - Support getting some of the server object "extras" if filtering on those
 *   (e.g. 'sdc-server lookup sysinfo.foo=bar').
 */
function lookupServers(args, callback)
{
    var options = [
        {
            names: ['help', 'h'],
            type: 'bool',
            help: 'Print this help and exit.'
        },
        {
            names: ['1'],
            type: 'bool',
            help: 'Error out if there are 0 or >1 matches to the given filters.'
        },
        {
            names: ['json', 'j'],
            type: 'bool',
            help: 'Print out a newline-separated JSON object for each ' +
                'matching server, instead of just the server UUIDs.'
        },
        {
            names: ['hostname', 'H'],
            type: 'bool',
            help: 'Typically server UUIDs are printed. Use this option to ' +
                'print hostnames instead.'
        },
        {
            names: ['comma', 'c'],
            type: 'bool',
            help: 'Join matching results in a single comma-separated list. ' +
                'This can be helpful for usage with other commands like ' +
                '"sdc-oneachnode -n $(sdc-server lookup ...) ...".'
        }
    ];

    var parser = dashdash.createParser({options: options});
    try {
        var opts = parser.parse({argv: args, slice: 0});
    } catch (optErr) {
        callback(optErr);
        return;
    }

    if (opts.help) {
        console.log(
            'Lookup servers matching given filters.\n' +
            '\n' +
            'Usage:\n' +
            '    sdc-server lookup [<options>] [<filters> ...]\n' +
            '\n' +
            'Options:\n' +
            parser.help() +
            '\n' +
            'Filters:\n' +
            '    FIELD=VALUE               exact string match\n' +
            '    FIELD=true|false          boolean match\n' +
            '    FIELD!=...                negated string or boolean match\n' +
            '    FIELD=~REGEX              regular expression match\n' +
            '    FIELD!~REGEX              negated regular expression match\n' +
            '    FIELD>NUMBER              numeric comparisons\n' +
            '    FIELD>=NUMBER             numeric comparisons\n' +
            '    FIELD<NUMBER              numeric comparisons\n' +
            '    FIELD<=NUMBER             numeric comparisons\n' +
            '\n' +
            'Examples:\n' +
            '    sdc-server lookup setup=true\n' +
            '    sdc-server lookup "ram>=100000"\n' +
            '    sdc-server lookup traits.foo!=bar\n' +
            '    sdc-server lookup traits.pkg!=aegean\n' +
            '    sdc-server lookup -H hostname=~^RA\n' +
            // JSSTYLED
            '    sdc-server lookup -j reservoir=true | json -ga uuid hostname boot_platform');
        callback();
        return;
    } else if (opts.json && opts.hostname) {
        callback(new Error('--json and --hostname are mutually exclusive'));
        return;
    } else if (opts.json && opts.comma) {
        callback(new Error('--json and --comma are mutually exclusive'));
        return;
    }

    try {
        var filters = filtersFromArgs(opts._args);
    } catch (filtersErr) {
        callback(filtersErr);
        return;
    }

    vasync.pipeline({arg: {}, funcs: [
        function getCnapiClient(ctx, cb) {
            createClient('CNAPI', function (err, cnapi) {
                if (err) {
                    err.api = 'CNAPI';
                } else {
                    ctx.cnapi = cnapi;
                }
                cb(err);
            });
        },
        function listServers(ctx, cb) {
            // Figure out what 'extras' to include to ServerList.
            var EXTRA_AND_FIELD_PATTERN = [
                // jsl:ignore
                ['agents', /^agents\./],
                ['sysinfo', /^sysinfo\./],
                ['vms', /^vms\./],
                ['disk', /^disk_/],
                ['memory', /^memory_/]
                // jsl:end
            ];
            var extras = [];
            EXTRA_AND_FIELD_PATTERN.forEach(function (extraAndPat) {
                var extra = extraAndPat[0];
                var pat = extraAndPat[1];
                for (var i = 0; i < filters.length; i++) {
                    if (pat.test(filters[i].key)) {
                        extras.push(extra);
                        break;
                    }
                }
            });

            var listOpts = {};
            if (extras.length > 0) {
                listOpts.extras = extras.join(',');
            }
            ctx.cnapi.listServers(listOpts, function (err, servers) {
                if (err) {
                    err.api = 'CNAPI';
                } else {
                    ctx.servers = servers;
                }
                cb(err);
            });
        },
        function filterServers(ctx, cb) {
            var DEBUG = (process.env.SDC_SERVER_LOOKUP_DEBUG === '1');
            var currServers = ctx.servers;
            for (var i = 0; i < filters.length; i++) {
                var filteredServers = [];
                for (var s = 0; s < currServers.length; s++) {
                    var server = currServers[s];
                    var filter = filters[i];
                    var sVal;
                    try {
                        sVal = dottedLookup(server, filter.key);
                    } catch (e) {
                        sVal = undefined;
                    }

                    var match;
                    switch (filter.type) {
                    case 'string':
                    case 'bool':
                        match = (sVal === filter.value);
                        break;
                    case 'number':
                        switch (filter.op) {
                        case '==':
                            match = (sVal === filter.value);
                            break;
                        case '>':
                            match = (sVal > filter.value);
                            break;
                        case '>=':
                            match = (sVal >= filter.value);
                            break;
                        case '<':
                            match = (sVal < filter.value);
                            break;
                        case '<=':
                            match = (sVal <= filter.value);
                            break;
                        default:
                            cb(new Error('unknown filter op: ' + filter.op));
                            return;
                        }
                        break;
                    case 'regexp':
                        if (sVal === undefined || sVal === null) {
                            match = false;
                        } else {
                            match = (filter.value.test(sVal));
                        }
                        break;
                    default:
                        cb(new Error('unknown filter type: ' + filter.type));
                        return;
                    }
                    if (filter.negated) {
                        match = !match;
                    }

                    if (match) {
                        if (DEBUG) console.error('debug: <server %s>.%s is %j '
                            + '(matches filter <key=%s negated=%s type=%s '
                            + 'value=%s>)', server.hostname, filter.key, sVal,
                            filter.key, filter.negated, filter.type,
                            filter.value);
                        filteredServers.push(server);
                    } else {
                        if (DEBUG) console.error('debug: <server %s>.%s is %j '
                            + '(does NOT match filter <key=%s negated=%s '
                            + 'type=%s value=%s>)', server.hostname,
                            filter.key, sVal, filter.key, filter.negated,
                            filter.type, filter.value);
                    }
                }
                currServers = filteredServers;
            }
            ctx.filteredServers = currServers;
            cb();
        },
        function ensureOne(ctx, cb) {
            if (opts['1'] && ctx.filteredServers.length !== 1) {
                cb(new Error(util.format('requested unique lookup (-1) ' +
                    'but found %d matching servers',
                    ctx.filteredServers.length)));
            } else {
                cb();
            }
        },
        function outputServers(ctx, cb) {
            if (opts.json) {
                for (var i = 0; i < ctx.filteredServers.length; i++) {
                    console.log(JSON.stringify(ctx.filteredServers[i]));
                }
                cb();
                return;
            }

            var results;
            if (opts.hostname) {
                results = ctx.filteredServers.map(function (s) {
                    return s.hostname;
                });
            } else {
                results = ctx.filteredServers.map(function (s) {
                    return s.uuid;
                });
            }
            if (results.length) {
                if (opts.comma) {
                    process.stdout.write(results.join(','));
                } else {
                    console.log(results.join('\n'));
                }
            }
            cb();
        }
    ]}, callback);
}

function outputAdminIP(server_uuid, callback) {
    var admin_ip;

    _getServer(server_uuid, function (err, s) {
        if (err) {
            callback(err);
            return;
        }

        admin_ip = netconfig.adminIpFromSysinfo(s['sysinfo']);
        if (!admin_ip) {
            callback(new Error('No admin IP found'));
            return;
        }

        console.log(admin_ip);
        callback();
    });
}

function deleteServer(server_uuid, callback)
{
    var cnapi;

    async.series([
        function (cb) {
            createClient('CNAPI', function (err, handle) {
                if (!err) {
                    cnapi = handle;
                }
                cb(err);
            });
        }, function (cb) {
            cnapi.del('/servers/' + server_uuid, function (err, result) {
                if (err) {
                    err.api = 'CNAPI';
                } else {
                    console.log('Server ' + server_uuid
                        + ' deleted successfully');
                }
                cb(err);
            });
        }
    ], callback);
}

function getJobs(server_uuid, opts, callback)
{
    assert.string(server_uuid, 'server_uuid');
    assert.object(opts, 'opts');
    assert.optionalNumber(opts.limit, 'opts.limit');
    assert.optionalString(opts.name, 'opts.name');
    assert.func(callback, 'callback');

    var result_jobs = [];
    var wfapi;

    async.series([
        function (cb) {
            createClient('WFAPI', function (err, handle) {
                if (!err) {
                    wfapi = handle;
                } else {
                    err.api = 'WFAPI';
                }
                cb(err);
            });
        }, function (cb) {
            var endpoint = '/jobs?target=' + server_uuid;

            if (opts && opts.name) {
                endpoint = endpoint + '&name=' + opts.name;
            }

            if (opts && opts.limit) {
                endpoint = endpoint + '&limit=' + opts.limit;
            }

            wfapi.get(endpoint, function (err, req, res, jobs) {
                if (err) {
                    err.api = 'WFAPI';
                    cb(err);
                    return;
                }

                result_jobs = jobs;
                cb();
            });
        }
    ], function (err) {
        if (err) {
            callback(err);
            return;
        }
        callback(null, result_jobs);
    });
}

function outputJobs(server_uuid, callback)
{
    getJobs(server_uuid, {}, function (err, jobs) {
        if (err) {
            callback(err);
            return;
        }

        if (jobs.length < 1) {
            console.log('No jobs for server ' + server_uuid);
            callback();
            return;
        }

        console.log(sprintf('%-28s %-12s %7s  %-24s  %-36s',
            'NAME', 'STATUS', 'ELAPSED', 'CREATED', 'UUID'));

        jobs.forEach(function (job) {

            console.log(sprintf('%-28s %-12s %7.1f  %24s  %36s', job.name,
                    job.execution, job.elapsed, job.created_at, job.uuid));
        });

        callback();
    });
}

function outputIps(server_uuid, callback)
{
    getNics(server_uuid, {}, function (err, nics) {
        if (err) {
            callback(err);
            return;
        }

        if (!nics || nics.length === 0) {
            return;
        }

        var ips = [];
        nics.forEach(function (n) {
            if (n.hasOwnProperty('ip') && ips.indexOf(n) === -1) {
                ips.push(n.ip);
            }
        });

        console.log(ips.join('\n'));
    });
}

function outputNics(server_uuid, callback)
{
    getNics(server_uuid, {}, function (err, nics) {
        if (err) {
            callback(err);
            return;
        }

        console.log(JSON.stringify(nics, null, 2));
    });
}

function outputSysinfo(server_uuid, callback)
{
    _getServer(server_uuid, function (err, server) {
        if (err) {
            callback(err);
            return;
        }
        console.log(JSON.stringify(server.sysinfo, null, 2));
    });
}

function runServerWorkflow(server_uuid, func, options, callback)
{
    var cnapi;
    var job_uuid;
    var wfapi;

    async.series([
        function (cb) {
            createClient('CNAPI', function (err, handle) {
                if (!err) {
                    cnapi = handle;
                } else {
                    err.api = 'CNAPI';
                }
                cb(err);
            });
        }, function (cb) {
            createClient('WFAPI', function (err, handle) {
                if (!err) {
                    wfapi = handle;
                } else {
                    err.api = 'WFAPI';
                }
                cb(err);
            });
        }, function (cb) {
            var e;
            var params = options.params || {};

            cnapi[func](server_uuid, params, function (err, result) {
                if (err) {
                    err.api = 'CNAPI';
                    cb(err);
                    return;
                }
                if (result.hasOwnProperty('job_uuid')) {
                    job_uuid = result.job_uuid;
                    cb();
                } else {
                    e = new Error('No job_uuid in result: '
                        + JSON.stringify(result));
                    e.api = 'CNAPI';
                    cb(e);
                }
            });
        }, function (cb) {
            var current_task;
            var endpoint = util.format('/jobs/%s', job_uuid);
            var ival;
            var line;
            var longest_line = 1;
            var result;
            var running = false;
            var startTime = Date.now(0);

            if (!options.sync) {
                // when we're async we just don't wait
                cb();
                return;
            }

            ival = setInterval(function () {
                if (!running) {
                    running = true;

                    wfapi.get(endpoint, function (err, req, res, job) {
                        var chain;
                        var e;
                        var execution;
                        var results;

                        if (err) {
                            err.api = 'WFAPI';
                            clearInterval(ival);
                            cb(err);
                            return;
                        }

                        execution = job.execution;

                        // for the 80 column glory
                        chain = job.chain;
                        results = job.chain_results;

                        if (results.length > 0) {
                            current_task = results[results.length - 1];
                        } else {
                            current_task = chain[0];
                        }
                        if ((current_task.hasOwnProperty('result') &&
                             current_task.result.length === 0) &&
                            (current_task.hasOwnProperty('error') &&
                             current_task.error.length === 0) &&
                            chain.length > results.length) {

                            current_task = chain[results.length];
                        }

                        if (execution === 'failed' ||
                            execution === 'cancelled') {
                            if (results[results.length - 1].error.length > 0) {
                                result = results[results.length - 1].name + ':'
                                    + results[results.length - 1].error;
                            } else {
                                result = results[results.length - 1].result
                                    + ':' + results[results.length - 1].result;
                            }
                            e = new Error('Job ' + execution + ' in "' + result
                                + '" (see /jobs/' + job_uuid + ' for details');
                            e.api = 'WFAPI';
                            clearInterval(ival);
                            cb(e);
                            return;
                        } else if (execution === 'succeeded') {
                            clearInterval(ival);
                            line = sprintf('\rJob(%s) - %0.1fs - completed '
                                + 'successfully', job_uuid,
                                (Date.now(0) - startTime) / 1000);
                            if (longest_line < line.length) {
                                longest_line = line.length;
                            }
                            // write the line with space padding at the end long
                            // enough to overwrite previous line(s)
                            console.log(line + sprintf('%'
                                + ((longest_line - line.length) + 1) + 's',
                                ' '));
                            cb();
                            return;
                        } else {
                            line = sprintf(
                                'Job(%s) - %0.1fs - currently %s: %s', job_uuid,
                                (Date.now(0) - startTime) / 1000, execution,
                                current_task.name);
                            if (longest_line < line.length) {
                                longest_line = line.length;
                            }
                            // write the line with space padding at the end long
                            // enough to overwrite previous line(s)
                            process.stdout.write('\r' + line + sprintf('%'
                                + ((longest_line - line.length) + 1) + 's',
                                ' '));
                        }

                        running = false;
                    });
                }
            }, 3000);
        }
    ], callback);
}

function dispatchCommand(command, args, callback)
{
    var rl;
    var server_uuid;

    switch (command) {
        case 'admin-ip':
            if (args.length !== 1 || !isUUID(args[0])) {
                usage();
                callback(new Error('admin-ip requires <uuid> argument'));
                return;
            }
            server_uuid = args[0];
            outputAdminIP(server_uuid, callback);
            break;

        case 'delete':
            if ((args.length !== 1 && args.length !== 2) ||
                !isUUID(args[args.length - 1])) {
                usage();
                callback(new Error('delete requires <uuid> argument'));
                return;
            }
            if (args.length === 2 && args[0] !== '-f') {
                usage();
                callback(new Error('Invalid delete flag: ' + args[0]));
                return;
            }
            server_uuid = args[args.length - 1];

            if (args.length === 1) {
                // prompt for confirm since no -f
                rl = readline.createInterface({
                    input: process.stdin,
                    output: process.stdout
                });

                rl.question('Are you sure you want to delete ' + server_uuid
                    + ' [Yes/No]? ', function (answer) {

                    if (answer.match(/^yes$/i)) {
                        deleteServer(server_uuid, callback);
                    } else {
                        callback(new Error('Cancelled at user request'));
                    }
                    rl.close();
                });
            } else {
                deleteServer(server_uuid, callback);
            }
            break;

        case 'ips':
            if (args.length !== 1 || !isUUID(args[0])) {
                usage();
                callback(new Error('ips requires <uuid> argument'));
                return;
            }
            server_uuid = args[0];
            outputIps(server_uuid, callback);
            break;

        case 'jobs':
            if (args.length !== 1 || !isUUID(args[0])) {
                usage();
                callback(new Error('jobs requires <uuid> argument'));
                return;
            }
            server_uuid = args[0];
            outputJobs(server_uuid, callback);
            break;

        case 'list':

            if (args.length > 0) {
                usage();
                callback(new Error('no arguments expected for list: '
                    + JSON.stringify(args)));
                return;
            }
            outputServerList(callback);
            break;

        case 'lookup':
            lookupServers(args, callback);
            break;

        case 'nics':
            if (args.length !== 1 || !isUUID(args[0])) {
                usage();
                callback(new Error('nics requires <uuid> argument'));
                return;
            }
            server_uuid = args[0];
            outputNics(server_uuid, callback);
            break;

        case 'sysinfo':
            if (args.length !== 1 || !isUUID(args[0])) {
                usage();
                callback(new Error('sysinfo requires <uuid> argument'));
                return;
            }
            server_uuid = args[0];
            outputSysinfo(server_uuid, callback);
            break;

        case 'setup':
        case 'update-nictags':
        case 'replace-nictags':
        case 'delete-nictags':
            if (command === 'setup' && args.length === 1 &&
                ['help', '-h'].indexOf(args[0]) !== -1) {
                setup_usage();
                callback();
                return;
            }

            if (args.length === 0 || (!isUUID(args[0]) && !isUUID(args[1]))) {
                usage();
                callback(new Error(command + ' requires <uuid> argument'));
                return;
            }

            var nics = {};
            var remain;
            var setupOpts = { params: {} };
            var sync;

            sync = (args[0].charAt(0) == '-');
            if (args.length > 1 && sync && args[0] !== '-s') {
                usage();
                callback(new Error('Invalid ' + command + ' flag: ' + args[0]));
                return;
            }

            if (sync) {
                server_uuid = args[1];
                remain = args.slice(2);
                setupOpts.sync = true;
            } else {
                server_uuid = args[0];
                remain = args.slice(1);
            }

            for (var p in remain) {
                var param = remain[p].split('=');
                if (param.length !== 2) {
                    usage();
                    callback(new Error('Invalid parameter: ' + remain[p]));
                    return;
                }

                if (param[0] === 'hostname') {
                    setupOpts.params.hostname = param[1];
                } else if (param[0] === 'postsetup_script') {
                    setupOpts.params.postsetup_script = param[1];
                } else if (param[0] === 'spares') {
                    setupOpts.params.disk_spares = param[1];
                } else if (param[0] === 'cache') {
                    setupOpts.params.disk_cache = param[1];
                } else if (param[0] === 'layout') {
                    setupOpts.params.disk_layout = param[1];
                } else {
                    var match = param[0].match(/^(.+)_nic$/);
                    if (!match) {
                        usage();
                        callback(new Error('Invalid nic tag parameter: ' +
                            param[0]));
                        return;
                    }
                    if (!nics.hasOwnProperty(param[1])) {
                        nics[param[1]] = [];
                    }

                    nics[param[1]].push(match[1]);
                }
            }

            if (Object.keys(nics).length !== 0) {
                setupOpts.params.nics = [];
                for (var n in nics) {
                    setupOpts.params.nics.push(
                        { mac: n, nic_tags_provided: nics[n] });
                }
            }

            var commandMatch = command.match(/^([^-]+)-nictags$/);
            if (commandMatch) {
                if (!setupOpts.params.nics) {
                    usage();
                    callback(new Error(
                        command + ' requires nic tags to be specified'));
                    return;
                }
                setupOpts.params.action = commandMatch[1];
            }

            runServerWorkflow(server_uuid,
                command === 'setup' ? 'setupServer' : 'updateNics',
                setupOpts, callback);

            break;

        default:
            usage();
            callback(new Error('unknown command: ' + command));
            break;
    }
}

function main()
{
    var args = process.argv.slice(3);
    var command = process.argv[2];

    if (!command || command.length < 1) {
        usage();
        process.exit(2);
    }

    getConfig(function (err) {
        dispatchCommand(command, args, function (err) {
            var api;
            var code = 'unknown';

            if (err) {
                api = '';
                if (err.hasOwnProperty('api')) {
                    api = err.api + ' ';
                }
                if (err.hasOwnProperty('statusCode')) {
                    code = err.statusCode;
                }
                if (code !== 'unknown') {
                    console.error(api + 'Error(' + code + '): ' + err.message);
                } else {
                    console.error(api + 'Error: ' + err.message);
                }
                process.exit(1);
                return;
            }
        });
    });
}

main();
