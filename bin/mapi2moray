#!/usr/bin/env node
// -*- mode: js -*-

// Copyright (c) 2012, Joyent, Inc., All rights reserved.
// Export data from MAPI PostgreSQL dump to be imported by moray

var fs = require('fs');
var path = require('path');
var util = require('util');
// Using Spanish here to avoid having to change all the "exists" references:
var existe = fs.exists || path.exists;
var existsSync = fs.existsSync || path.existsSync;


///--- Globals

var directory, datacenter, admin_uuid;  // set in `process_argv()`.

var NICS_READ = 0;
var NICS_WRITTEN = 0;

var Types = ['vms', 'zones', 'servers'];

var NULL = '\\N';

// position of the uuid - number of columns - position of owner_uuid (if
// applicable) - primary network ID (if applicable)
var UUID_POSITIONS = {
    'servers': [16, 29],
    'zones': [1, 45, 35, 43],
    'vms': [1, 30, 3, 27],
    'datasets': [4, 28],
    'zfs_storage_pools': [1, 11]
};

var IMAGES, NETWORKS, NETWORK_POOL_NETWORKS, NICS, NIC_NIC_TAGS, NIC_TAGS,
    SERVERS, SUBNETS, TAGS, VMS, ZONES, ZPOOLS, PACKAGES;

var IPS_NEEDED = {};

// Write streams for files that are too big to write all at once
var IP_FILES = {};
var NIC_FILE;


///--- Helpers
// NOTE: Shamelessly copying from capi2lidf.sh, maybe should consider sharing?.

function err_and_exit() {
    console.error.apply(arguments);
    process.exit(1);
}


// The datacenter name is stored in the config file, not in mapi.
// Pass in the datacenter name as an argument.
function usage(msg, code) {
    if (typeof(msg) === 'string') {
        console.error(msg);
    }

    console.error('%s <directory> <dc-name> <admin-uuid>',
        path.basename(process.argv[1]));
    process.exit(code || 0);
}



function process_argv() {
    if (process.argv.length !== 5) {
        usage(null, 1);
    }

    try {
        var stats = fs.statSync(process.argv[2]);
        if (!stats.isDirectory()) {
            usage(process.argv[2] + ' is not a directory', 1);
        }
    } catch (e) {
        usage(process.argv[2] + ' is invalid: ' + e.toString(), 1);
    }

    directory = process.argv[2];
    datacenter = process.argv[3];
    admin_uuid = process.argv[4];
}



function close_files() {
    if (NIC_FILE) {
        NIC_FILE.end();
    }

    if (Object.keys(IP_FILES).length !== 0) {
        for (var f in IP_FILES) {
            IP_FILES[f].end();
        }
    }
}



function read_lines(file, callback) {
    return fs.readFile(file, 'utf8', function(err, data) {
        if (err) {
            return callback(err);
        }

        return callback(null, data.split('\n'));
    });
}



function read_lines_sync(file) {
    try {
        var data = fs.readFileSync(file, 'utf8');
        return data.split('\n');
    } catch (err) {
        return err_and_exit('Error loading '+ file + ': %s', err.toString());
    }
}



function read_lines_chunked(file, dataCallback, doneCallback) {
    var leftover = '';
    var rs = fs.createReadStream(file, { flags: 'r', encoding: 'utf8' });

    rs.on('data', function (data) {
        var pieces = (leftover + data.toString()).split(/\n/g);
        leftover = pieces.pop();

        return dataCallback(pieces);
    });

    rs.on('end', function () {
        if (leftover.length !== 0) {
            dataCallback(leftover);
        }
        return doneCallback();
    });
}



function generate_uuid(callback) {
    var exec = require('child_process').exec;
    // var child = exec("uuidgen | tr '[A-Z]' '[a-z]'", function (error, stdout, stderr) {
    var child = exec('/usr/bin/uuid', function (error, stdout, stderr) {
        if (error) {
            return callback(error);
        }

        return callback(null, stdout.replace(/^\s+|\s+$/g, ''));
    });
}



function macToNum(addr) {
    return parseInt(addr.replace(/[-:]/g, ''), 16);
}



function get_addressable(id, type) {
    var belongs_to = {};
    switch (type) {
    case 'VM':
        belongs_to.type = 'zone';
        belongs_to.uuid = VMS[id].uuid;
        belongs_to.owner_uuid = VMS[id].owner_uuid;
        belongs_to.primary_network_uuid = VMS[id].primary_network_uuid;
        break;
    case 'Zone':
        belongs_to.type = 'zone';
        belongs_to.uuid = ZONES[id].uuid;
        belongs_to.owner_uuid = ZONES[id].owner_uuid;
        belongs_to.primary_network_uuid = ZONES[id].primary_network_uuid;
        break;
    case 'Server':
        belongs_to.type = 'server';
        belongs_to.uuid = SERVERS[id];
        belongs_to.owner_uuid = admin_uuid;
        break;
    case 'Nic':
        belongs_to.type = 'other';
        belongs_to.uuid = admin_uuid;
        belongs_to.owner_uuid = admin_uuid;
        break;
    default:
        belongs_to = null;
    }

    return belongs_to;
}



// Real stuff goes here:

// This function will read a table and create a mapping between
// row ids and uuids like
//
// { '1': <uuid> }
//
// Then on a table like zones we are table to replace server_id with
// the corresponding server_uuid
function transform_uuids(table) {
    var util = require('util');

    var file = directory + '/' + table + '.dump';
    var lines = read_lines_sync(file);
    var hash = {};
    var total = lines.length;
    var uuid = UUID_POSITIONS[table][0];
    var columns = UUID_POSITIONS[table][1];

    lines.forEach(function(line) {
        var pieces = line.split('\t');
        if (pieces.length < columns) {
            return;
        }

        hash[pieces[0]] = pieces[uuid];
    });

    return hash;
}

// This function will read a table and create a mapping between
// row ids and uuids and owner uuids like
//
// { '1': { uuid: <uuid>, owner_uuid: <uuid> } }
//
function transform_vm_uuids(table) {
    var util = require('util');

    var file = directory + '/' + table + '.dump';
    var lines = read_lines_sync(file);
    var hash = {};
    var total = lines.length;
    var uuid = UUID_POSITIONS[table][0];
    var columns = UUID_POSITIONS[table][1];
    var owner_uuid = UUID_POSITIONS[table][2];
    var primary_network_id = UUID_POSITIONS[table][3];

    lines.forEach(function(line) {
        var pieces = line.split('\t');
        if (pieces.length < columns) {
            return;
        }

        hash[pieces[0]] = {
            owner_uuid: pieces[owner_uuid],
            primary_network_id: pieces[primary_network_id],
            uuid: pieces[uuid]
        };
    });

    return hash;
}

/**
 * 0 -- id
 * 1 -- number
 * 2 -- subnet_id
 * 3 -- held_for_server_id
 * 4 -- reserved
 * 5 -- addressable_type
 * 6 -- addressable_id
 * 7 -- created_at
 * 8 -- updated_at
 * 9 -- last_seen_at
 */
function transform_ips(file, callback) {
    var errs = [];
    var subnetErrs = {};
    var num = 0;
    var written = 0;

    return read_lines_chunked(file, function (lines) {
        lines.forEach(function (line) {
            var pieces = line.split('\t').map(function (e) {
                return e === NULL ? null : e;
            });

            if (pieces.length !== 10) {
                return;
            }

            var reserved = (pieces[4] === 't');
            var subnet_id = pieces[2];

            num++;

            if (IPS_NEEDED.hasOwnProperty(pieces[0])) {
                //console.log('  needed IP: %d=%d', pieces[0], pieces[1]);
                IPS_NEEDED[pieces[0]] = {
                  ip: pieces[1],
                  network: SUBNETS[subnet_id]
                };
            }

            // Don't add the IP if it's not reserved and doesn't belong to
            // anything
            if (!reserved && pieces[6] === null) {
                return;
            }

            var ip = {
                ip: pieces[1],
                reserved: reserved
            };

            if (!SUBNETS.hasOwnProperty(subnet_id)) {
                return;
                // Should maybe warn here instead?
                // if (!subnetErrs.hasOwnProperty(subnet_id)) {
                //     subnetErrs[subnet_id] = new Error(
                //         'IP "' + pieces[1] + '" has invalid subnet ID "' +
                //         subnet_id + '"');
                // }
            }

            if (pieces[6] !== null && pieces[5] !== null) {
                var belongs_to = get_addressable(pieces[6], pieces[5]);
                if (!belongs_to) {
                    errs.push(new Error('IP "' + pieces[1] +
                        '" has unknown owner ' + pieces[5] + '/' +
                        pieces[6]));
                    return;
                }

                ip.belongs_to_type = belongs_to.type;
                ip.belongs_to_uuid = belongs_to.uuid;
                ip.owner_uuid = belongs_to.owner_uuid;
                if (IPS_NEEDED.hasOwnProperty(pieces[0])) {
                    IPS_NEEDED[pieces[0]].network = SUBNETS[subnet_id];
                }
            }

            if (!IP_FILES.hasOwnProperty(subnet_id)) {
                IP_FILES[subnet_id] = fs.createWriteStream(
                    directory + '/napi_ips_' +
                    SUBNETS[subnet_id].replace(/-/g, '_') + '.moray',
                    { flags: 'w', encoding: 'utf8' });
            }

            written++;
            IP_FILES[subnet_id].write(JSON.stringify(ip) + '\n', 'utf8');

            //console.log(JSON.stringify(ip, null, 2));
        });

    }, function () {
        console.log('   IPs read: %d, written: %d', num, written);
        for (var e in subnetErrs) {
            errs.push(subnetErrs[e]);
        }

        if (errs.length !== 0) {
            return callback(errs);
        }

        // We now have the IP data necessary in IPS_NEEDED to write out the
        // networks and nics
        return finish_networks(function (err) {
            if (err) {
                return callback(err);
            }

            return finish_nics(callback);
        });
    });
}

/**
 * 0 -- id
 * 1 -- name
 * 2 -- description
 * 3 -- vlan_id
 * 4 -- subnet_id
 * 5 -- admin
 * 6 -- created_at
 * 7 -- updated_at
 * 8 -- nic_tag_id
 */
function transform_networks(file, callback) {
    NETWORKS = {};

    return read_lines(file, function (err, lines) {
        if (err) {
            return callback(err);
        }

        var errs = [];
        var done = 0;

        lines.forEach(function (line) {
            var pieces = line.split('\t').map(function (e) {
                return e === NULL ? null : e;
            });

            if (pieces.length !== 9) {
                done++;
                return;
            }

            generate_uuid(function (err, uuid) {
                if (err) {
                    errs.push(err);
                } else {
                    process_network_line(uuid, pieces, errs);
                }

                done++;

                if (done === lines.length) {
                    if (errs.length !== 0) {
                        return callback(errs);
                    }

                    // We now have UUIDs to transform primary_network_id in
                    // the VMS and ZONES tables
                    for (var zid in ZONES) {
                      var prim_net = NETWORKS[ZONES[zid].primary_network_id];
                      if (prim_net) {
                        ZONES[zid].primary_network = prim_net.uuid;
                      }
                    }

                    for (var vid in VMS) {
                      var prim_net = NETWORKS[VMS[vid].primary_network_id];
                      if (prim_net) {
                        VMS[vid].primary_network = prim_net.uuid;
                      }
                    }

                    return callback();
                }
            });
        });
    });
}

/**
 * 0 -- id
 * 1 -- name
 * 2 -- created_at
 * 3 -- updated_at
 */
function transform_network_pools(file, callback) {
    var errs = [];
    var pools = [];

    return read_lines(file, function (err, lines) {
        if (err) {
            return callback(err);
        }

        lines.forEach(function (line) {
            var pieces = line.split('\t').map(function (e) {
                return e === NULL ? null : e;
            });

            if (pieces.length !== 4) {
                return;
            }

            if (!NETWORK_POOL_NETWORKS.hasOwnProperty(pieces[0])) {
                errs.push(new Error('network pool ' + pieces[1] +
                    ' (' + pieces[0] + ') has no networks'));
                    return;
            }

            generate_uuid(function (err, uuid) {
                if (err) {
                    errs.push(err);
                } else {
                    var pool = {
                        name: pieces[1],
                        networks: NETWORK_POOL_NETWORKS[pieces[0]],
                        uuid : uuid,
                    };

                    pools.push(JSON.stringify(pool));
                    //console.log(JSON.stringify(pool));
                }

            });
        });

        if (errs.length !== 0) {
            return callback(errs);
        }

        if (pools.length === 0) {
            return callback();
        }

        return fs.writeFile(directory
            + '/napi_network_pools.moray', pools.join('\n'),
            'utf8', callback);
    });
}

/**
 * 0 -- id
 * 1 -- network_id
 * 2 -- network_pool_id
 * 3 -- created_at
 * 4 -- updated_at
 */
function transform_network_pool_networks(file, callback) {
    var errs = [];
    NETWORK_POOL_NETWORKS = {};

    return read_lines(file, function (err, lines) {
        if (err) {
            return callback(err);
        }

        lines.forEach(function (line) {
            var pieces = line.split('\t').map(function (e) {
                return e === NULL ? null : e;
            });

            if (pieces.length !== 5) {
                return;
            }

            var network_id = pieces[1];
            var pool_id = pieces[2];

            if (!NETWORKS.hasOwnProperty(network_id)) {
                errs.push(new Error('network pool ' + pieces[2] +
                    ' contains non-existant network "' + pieces[1] + '"'));
                    return;
            }

            if (!NETWORK_POOL_NETWORKS.hasOwnProperty(pool_id)) {
                NETWORK_POOL_NETWORKS[pool_id] = [];
            }

            NETWORK_POOL_NETWORKS[pool_id].push(NETWORKS[network_id].uuid);

            //console.log(JSON.stringify(NETWORK_POOL_NETWORKS[pool_id]));
        });

        if (errs.length !== 0) {
            return callback(errs);
        }

        return callback();
    });
}

/**
 * 0 -- id
 * 1 -- network_id
 * 2 -- ip_id
 * 3 -- created_at
 * 4 -- updated_at
 */
function transform_network_ips(file, callback) {
    return read_lines(file, function (err, lines) {
        if (err) {
            return callback(err);
        }

        lines.forEach(function (line) {
            var pieces = line.split('\t').map(function (e) {
                return e === NULL ? null : e;
            });

            if (pieces.length !== 5) {
                return;
            }

            var network_id = pieces[1];

            if (!NETWORKS.hasOwnProperty(network_id)) {
                //console.error(
                //    '  network_ips table refers to non-existant network "%d"',
                //    network_id);
                return;
            }

            if (!NETWORKS[network_id].hasOwnProperty('resolver_ids')) {
                NETWORKS[network_id].resolver_ids = [];
            }

            NETWORKS[network_id].resolver_ids.push(pieces[2]);
            IPS_NEEDED[pieces[2]] = true;

            //console.log(JSON.stringify(NETWORKS[network_id], null, 2));
        });

        return callback();
    });
}

/**
 * 0 -- id
 * 1 -- address
 * 2 -- interface
 * 3 -- addressable_id
 * 4 -- ip_id
 * 5 -- created_at
 * 6 -- updated_at
 * 7 -- addressable_type
 * 8 -- type
 */
function transform_nics(file, callback) {
    NICS = {};
    var err = false;

    NIC_FILE = fs.createWriteStream(directory + '/napi_nics.moray',
        { flags: 'w', encoding: 'utf8' });

    return read_lines_chunked(file, function (lines) {
        lines.forEach(function (line) {
            var pieces = line.split('\t').map(function (e) {
                return e === NULL ? null : e;
            });

            if (pieces.length !== 9) {
                return;
            }

            NICS_READ++;
            var belongs_to = get_addressable(pieces[3], pieces[7]);
            // An unknown belongs_to just means that the nic was destroyed in
            // MAPI but the record was left around to prevent reusing that MAC
            if (!belongs_to) {
                //console.error('Nic "' + pieces[1] + '" has unknown owner '
                //    + pieces[7] + '/' + pieces[3]);
                return;
            }

            var nic = {
                belongs_to_type: belongs_to.type,
                belongs_to_uuid: belongs_to.uuid,
                interface: pieces[2],
                mac: macToNum(pieces[1]),
                owner_uuid: belongs_to.owner_uuid
            };

            if (NIC_NIC_TAGS.hasOwnProperty(pieces[0])) {
                // Physical nics only can provide nic tags.  Anything else
                // is a vnic that is over a nic tag.
                if (nic.belongs_to_type === 'server'
                    && pieces[8] === 'physical') {
                    nic.nic_tags_provided = ','
                        + NIC_NIC_TAGS[pieces[0]].join(',') + ',';
                } else {
                    nic.nic_tag = NIC_NIC_TAGS[pieces[0]][0];
                }
            }

            if (pieces[4] !== null) {
                IPS_NEEDED[pieces[4]] = true;
                nic.ip_id = pieces[4];
            } else {
                // nic does not have an IP, so we can write it now
                delete nic.interface;
                NIC_FILE.write(JSON.stringify(nic, 'utf8') + '\n');
                NICS_WRITTEN++;
                //console.log('Writing nic %s (%d) now', pieces[1], nic.mac);
                return;
            }

            nic.mac_str = pieces[1];
            //console.log(JSON.stringify(nic, null, 2));

            if (!NICS.hasOwnProperty(nic.belongs_to_uuid)) {
              NICS[nic.belongs_to_uuid] = [];
            }

            NICS[nic.belongs_to_uuid].push(nic);
        });

    }, function () {
        if (err) {
          return callback(new Error('Error transforming nics'));
        }

        return callback();
    });
}

/**
 * 0 -- id
 * 1 -- nic_id
 * 2 -- nic_tag_id
 * 3 -- created_at
 * 4 -- updated_at
 */
function transform_nic_nic_tags(file, callback) {
    NIC_NIC_TAGS = {};
    var errs = [];

    return read_lines_chunked(file, function (lines) {
        lines.forEach(function (line) {
            var pieces = line.split('\t').map(function (e) {
                return e === NULL ? null : e;
            });

            if (pieces.length !== 5) {
                return;
            }


            if (!NIC_NIC_TAGS.hasOwnProperty(pieces[1])) {
                NIC_NIC_TAGS[pieces[1]] = [];
            }


            if (!NIC_TAGS.hasOwnProperty(pieces[2])) {
                errs.push(new Error('nic_nic_tag ' + pieces[0] +
                    ' (nic ' + pieces[1] + '%d): unknown nic tag ID '
                    + pieces[2]));
            }

            NIC_NIC_TAGS[pieces[1]].push(NIC_TAGS[pieces[2]].name);

            //console.log('nic %d: %s', pieces[1],
            //    JSON.stringify(NIC_NIC_TAGS[pieces[1]]));
        });

    }, function () {
        if (errs.length !== 0) {
            return callback(errs);
        }

        return callback();
    });
}

/**
 * 0 -- id
 * 1 -- name
 * 2 -- created_at
 * 3 -- updated_at
 */
function transform_nic_tags(file, callback) {
    NIC_TAGS = {};
    var tags = [];

    return read_lines(file, function (err, lines) {
        if (err) {
            return callback(err);
        }

        var changes = [];
        var errs = [];
        var done = 0;

        lines.forEach(function (line) {
            var pieces = line.split('\t');

            if (pieces.length !== 4) {
                done++;
                return;
            }

            generate_uuid(function (err, uuid) {
                if (err) {
                    errs.push(err);
                } else {
                    var tag = { uuid: uuid, name: pieces[1] };
                    NIC_TAGS[pieces[0]] = tag;
                    tags.push(JSON.stringify(tag));
                    //console.log(JSON.stringify(tag));
                }

                done++;

                if (done === lines.length) {
                    if (errs.length !== 0) {
                        return callback(errs[0]);
                    }

                    fs.writeFile(directory + '/napi_nic_tags.moray',
                        tags.join('\n'), 'utf8', callback);
                }
            });
        });
    });
}

/**
 * 0 -- id
 * 1 -- bit_count
 * 2 -- description
 * 3 -- start_ip_id
 * 4 -- default_gateway_ip_id
 * 5 -- router_id
 * 6 -- role
 * 7 -- start_provisionable_ip_id
 * 8 -- end_provisionable_ip_id
 * 9 -- network_id
 * 10 -- created_at
 * 11 -- updated_at
 */
function transform_subnets(file, callback) {
    SUBNETS = {};

    return read_lines(file, function (err, lines) {
        if (err) {
            return callback(err);
        }

        var errs = [];

        lines.forEach(function (line) {
            var pieces = line.split('\t').map(function (e) {
                return e === NULL ? null : e;
            });

            if (pieces.length !== 12) {
                return;
            }

            var network_id = pieces[9];

            if (!NETWORKS.hasOwnProperty(network_id)) {
                errs.push(new Error('subnet "' + pieces[2] + '" (id=' +
                    pieces[0] + ') refers to missing network ID '
                    + network_id));
                return;
            }

            var subnet = {
                subnet_bits: pieces[1],
                subnet_start_ip_id: pieces[3],
                provision_start_ip_id: pieces[7],
                provision_end_ip_id: pieces[8],
            };

            if (pieces[4]) {
                subnet.gateway_id = pieces[4];
                IPS_NEEDED[pieces[4]] = true;
            }

            IPS_NEEDED[subnet.subnet_start_ip_id] = true;
            IPS_NEEDED[subnet.provision_start_ip_id] = true;
            IPS_NEEDED[subnet.provision_end_ip_id] = true;

            for (var p in subnet) {
                NETWORKS[network_id][p] = subnet[p];
            }

            SUBNETS[pieces[0]] = NETWORKS[network_id].uuid;

            //console.log(JSON.stringify(NETWORKS[network_id], null, 2));
        });

        if (errs.length !== 0) {
            return callback(errs);
        }

        return callback();
    });
}

// This function will read the tags table and create a mapping between
// machine ids and tag key/values like:
//
// {
//   "zones": {'1': { key: value, foo: bar } },
//   "vms": {'3': { bar: baz } }
// }
//
// Since tags can belong to zones and vms, the hash is provided in this form.
function transform_tags(table) {
    var util = require('util');

    var file = directory + '/' + table + '.dump';
    var lines = read_lines_sync(file);
    var hash = { "Zone": {}, "VM": {} };
    var total = lines.length;

    var TAG_KEY = 1;
    var TAG_VALUE = 2;
    var TAGGABLE_ID = 3;
    var TAGGABLE_TYPE = 4;
    var columns = 7;

    lines.forEach(function(line) {
        var pieces = line.split('\t');
        if (pieces.length < columns) {
            return;
        }

        var obj = hash[ pieces[TAGGABLE_TYPE] ][ pieces[TAGGABLE_ID] ];

        if (!obj) {
            obj = [];
        }

        obj.push( pieces[TAG_KEY] + '=' + pieces[TAG_VALUE] );
        hash[ pieces[TAGGABLE_TYPE] ][ pieces[TAGGABLE_ID] ] = obj;
    });

    return hash;
}

function transform_vms(file, callback) {
    if (can_transform_vms() === false) {
        return callback();
    }

    var util = require('util');
    var table = (file.indexOf('vms') !== -1) ? 'vms': 'zones';

    return read_lines(file, function(err, lines) {
        if (err) {
          return err_and_exit('Error loading vms file: %s', err.toString());
        }

        var changes = [];
        var total = lines.length;

        // How to access these values?
        //
        //     datasets
        //     nics
        //     delegate_dataset
        lines.forEach(function(line) {
            var change;
            var pieces = line.split('\t'), uuid;

            if (pieces.length == 45) {
                change = vm_from_zone(pieces);
            } else if (pieces.length == 30) {
                change = vm_from_vm(pieces);
            } else {
                return;
            }

            if (change !== false) {
                changes.push(JSON.stringify(change));
            }
        });

        return fs.writeFile(directory + '/vmapi_' + table + '.moray',
            changes.join('\n'), 'utf8', callback);
    });
}

/**
 * 0 -- id
 * 1 -- name
 * 2 -- alias
 * 3 -- owner_uuid
 * 4 -- dataset_id
 * 5 -- server_id
 * 6 -- deactivated_at
 * 7 -- deactivated_by
 * 8 -- destroyed_at
 * 9 -- destroyed_by
 * 10 -- created_at
 * 11 -- updated_at
 * 12 -- creation_state
 * 13 -- swap
 * 14 -- customer_metadata
 * 15 -- internal_metadata
 * 16 -- ram
 * 17 -- customer_assigned_at
 * 18 -- zfs_io_priority
 * 19 -- cpu_cap
 * 20 -- cpu_shares
 * 21 -- lightweight_processes
 * 22 -- disk
 * 23 -- setup_at
 * 24 -- setup_by
 * 25 -- disks
 * 26 -- zfs_storage_pool_id
 * 27 -- primary_network_id
 * 28 -- vcpus
 * 29 -- latest_heartbeat_cache
 */
function vm_from_vm(pieces) {
    var change;
    var created_at = (pieces[23] == '\\N' ? undefined : new Date(pieces[23]).getTime());
    var destroyed = (pieces[8] == '\\N' ? undefined : new Date(pieces[8]).getTime());
    var last_mod = (pieces[11] == '\\N' ? undefined : new Date(pieces[11]).getTime());
    var zone_state = (pieces[29] == '\\N' ? '' : pieces[29]);
    var brand = 'kvm';
    var uuid = pieces[1];
    var owner_uuid = pieces[3];

    var state;
    if (destroyed !== undefined) {
        zone_state = 'destroyed';
        state = 'destroyed';
    } else {
        return false;
    }

    change = {
        uuid: uuid,
        owner_uuid: owner_uuid,
        server_uuid: SERVERS[pieces[5]],
        image_uuid: IMAGES[pieces[4]],
        brand: brand,
        max_physical_memory: Number(pieces[16]),
        max_swap: Number(pieces[13]),
        max_lwps: Number(pieces[21]),
        quota: Number(pieces[22]),
        cpu_shares: Number(pieces[20]),
        zfs_io_priority: Number(pieces[18]),
        ram: Number(pieces[16]),
        internal_metadata: pieces[15],
        customer_metadata: pieces[14],
        cpu_cap: Number(pieces[19]),
        zone_state: zone_state,
        state: state,
        create_timestamp: created_at,
        last_modified: last_mod,
        destroyed: destroyed,
        vcpus: Number(pieces[28]),
        disks: pieces[25],
        zpool: ZPOOLS[pieces[26]] || 'zones'
    };

    // An empty alias is not supported
    if (pieces[2] != '\\N') {
        change.alias = pieces[2];
    }

    var tags = TAGS['VM'][ pieces[0] ];
    if (tags) {
        change.tags = JSON.stringify(tags);
    }

    return change;
}

/**
 * 0 -- id
 * 1 -- name
 * 2 -- customer_id
 * 3 -- reclaimed_at
 * 4 -- setup_at
 * 5 -- setup_by
 * 6 -- cloned_at
 * 7 -- deactivated_at
 * 8 -- destroyed_at
 * 9 -- id_in_ding
 * 10 -- nfs_storage_path
 * 11 -- successful_create_status
 * 12 -- customer_assigned_at
 * 13 -- creation_state
 * 14 -- zfs_storage_pool_id
 * 15 -- disk_used_in_gigabytes
 * 16 -- in_use
 * 17 -- synced_at
 * 18 -- origin_id
 * 19 -- server_id
 * 20 -- ssh_dsa_fingerprint
 * 21 -- ssh_rsa_fingerprint
 * 22 -- authorized_keys
 * 23 -- reserved
 * 24 -- deactivated_by
 * 25 -- destroyed_by
 * 26 -- virtual_ip_id
 * 27 -- cpu_cap
 * 28 -- internal_ips_only
 * 29 -- dataset_id
 * 30 -- ram
 * 31 -- disk
 * 32 -- swap
 * 33 -- lightweight_processes
 * 34 -- cpu_shares
 * 35 -- owner_uuid
 * 36 -- created_at
 * 37 -- updated_at
 * 38 -- alias
 * 39 -- zfs_io_priority
 * 40 -- customer_metadata
 * 41 -- internal_metadata
 * 42 -- blocked_outgoing_ports
 * 43 -- primary_network_id
 * 44 -- latest_heartbeat_cache
 */
function vm_from_zone(pieces) {
    var change;
    var created_at = (pieces[4] == '\\N' ? undefined : new Date(pieces[4]).getTime());
    var destroyed = (pieces[8] == '\\N' ? undefined : new Date(pieces[8]).getTime());
    var last_mod = (pieces[37] == '\\N' ? undefined : new Date(pieces[37]).getTime());
    var zone_state = (pieces[44] == '\\N' ? '' : pieces[44]);
    var brand = 'joyent';
    var uuid = pieces[1];
    var owner_uuid = pieces[35];

    var state;

    if (destroyed !== undefined) {
        zone_state = 'destroyed';
        state = 'destroyed';
    } else {
        return false;
    }

    change = {
        uuid: uuid,
        owner_uuid: owner_uuid,
        server_uuid: SERVERS[pieces[19]],
        image_uuid: IMAGES[pieces[29]],
        brand: brand,
        max_physical_memory: Number(pieces[30]),
        max_swap: Number(pieces[32]),
        max_lwps: Number(pieces[33]),
        quota: Number(pieces[31]),
        cpu_shares: Number(pieces[34]),
        zfs_io_priority: Number(pieces[39]),
        ram: Number(pieces[30]),
        internal_metadata: pieces[41],
        customer_metadata: pieces[40],
        cpu_cap: Number(pieces[27]),
        zone_state: zone_state,
        state: state,
        create_timestamp: created_at,
        last_modified: last_mod,
        destroyed: destroyed,
        zpool: ZPOOLS[pieces[14]] || 'zones'
    };

    // An empty alias is not supported
    if (pieces[38] != '\\N') {
        change.alias = pieces[38];
    }

    var tags = TAGS['Zone'][ pieces[0] ];
    if (tags) {
        change.tags = JSON.stringify(tags);
    }

    return change;
}

function process_network_line(uuid, pieces, errs) {
    var id = pieces[0];
    var name = pieces[1];
    var subnet_id = pieces[4];
    var nic_tag_id = pieces[8];

    if (!NIC_TAGS.hasOwnProperty(nic_tag_id)) {
        errs.push(new Error('network "' + name + '" (id=' + id +
              ') refers to missing nic tag ID ' + nic_tag_id));
        return;
    }

    var net = {
        name: name,
        nic_tag: NIC_TAGS[nic_tag_id].name,
        uuid: uuid,
        vlan_id: pieces[3]
    };

    NETWORKS[id] = net;
    //console.log(JSON.stringify(net, null, 2));
}

function finish_networks(callback) {
    var errs = [];
    var nets = [];

    for (var n in NETWORKS) {
        var net = NETWORKS[n];

        net.provision_start_ip = IPS_NEEDED[net.provision_start_ip_id] ?
            IPS_NEEDED[net.provision_start_ip_id].ip : null;
        net.provision_end_ip = IPS_NEEDED[net.provision_end_ip_id] ?
            IPS_NEEDED[net.provision_end_ip_id].ip : null;
        net.subnet_start_ip = IPS_NEEDED[net.subnet_start_ip_id] ?
            IPS_NEEDED[net.subnet_start_ip_id].ip : null;

        if (net.hasOwnProperty('gateway_id')) {
            net.gateway = IPS_NEEDED[net.gateway_id] ?
                IPS_NEEDED[net.gateway_id].ip : null;
        }

        ['provision_start_ip', 'provision_end_ip', 'subnet_start_ip',
            'gateway'].forEach(function (ipKey) {
            if (net.hasOwnProperty(ipKey) && (!net[ipKey] ||
                net[ipKey] === true)) {
                var idKey = ipKey + '_id';
                errs.push(new Error('network ' + n + ' has invalid ',
                    idKey + ' ' + net[idKey]));
            }
        });

        delete net.subnet_start_ip_id;
        delete net.provision_start_ip_id;
        delete net.provision_end_ip_id;
        delete net.gateway_id;

        if (net.hasOwnProperty('resolver_ids')) {
            net.resolvers = [];
            net.resolver_ids.forEach(function (id) {
                if (!IPS_NEEDED.hasOwnProperty(id)
                    || IPS_NEEDED[id] === true) {
                    errs.push(new Error('network ' + n +
                        ' has invalid resolver IP ID ' + id));
                    return;
                }
                net.resolvers.push(IPS_NEEDED[id].ip);
            });
            delete net.resolver_ids;
        }

        nets.push(JSON.stringify(net));
        //console.log(JSON.stringify(net, null, 2));
    }

    if (errs.length !== 0) {
        return callback(errs);
    }

    fs.writeFile(directory + '/napi_networks.moray',
        nets.join('\n'), 'utf8', callback);
}

function finish_nics(callback) {
    var err = false;

    for (var uuid in NICS) {
        var vmNics = NICS[uuid].sort(function (a, b) {
          return (a.interface < b.interface);
        });

        var primary_found = false;

        vmNics.forEach(function (nic) {
            if (!IPS_NEEDED.hasOwnProperty(nic.ip_id)) {
                err = true;
                console.error('nic %s has invalid IP ID %d', nic.mac_str,
                    nic.ip_id);
                return;
            }

            var ip = IPS_NEEDED[nic.ip_id];
            nic.ip = ip.ip;
            nic.network_uuid = ip.network;

            if (!primary_found && ip.network == ip.primary_network_uuid) {
              nic.primary = true;
              primary_found = true;
            }

            delete nic.ip_id;
            delete nic.mac_str;
            delete nic.interface;

            //console.log(JSON.stringify(nic));
        });

        if (!primary_found) {
          vmNics[0].primary = true;
        }

        NICS_WRITTEN += vmNics.length;
        NIC_FILE.write(vmNics.map(function (n) {
          return JSON.stringify(n);
        }).join('\n') + '\n', 'utf8');
    }

    console.log('   Nics read: %d, written: %d', NICS_READ, NICS_WRITTEN);
    if (err) {
        return callback(new Error('Nics have invalid IP IDs'));
    }

    return callback();
}

/**
 * 0 -- id
 * 1 -- hostname
 * 2 -- rack_id
 * 3 -- server_role_id
 * 4 -- ram_in_megabytes
 * 5 -- target_utilization_in_megabytes
 * 6 -- reserved
 * 7 -- setup_at
 * 8 -- cpu_cores
 * 9 -- public_interface
 * 10 -- private_interface
 * 11 -- admin_ssh_access_preferred
 * 12 -- vendor_number
 * 13 -- model
 * 14 -- manufacturer
 * 15 -- operating_system
 * 16 -- uuid
 * 17 -- is_headnode
 * 18 -- latest_boot_at
 * 19 -- target_image_set_at
 * 20 -- created_at
 * 21 -- updated_at
 * 22 -- platform_image_id
 * 23 -- swap_in_gigabytes
 * 24 -- current_status
 * 25 -- hardware_uuid
 * 26 -- boot_args
 * 27 -- vm_capable
 * 28 -- setting_up_at
 */

function transform_servers(file, callback) {
    read_lines(file, function (error, lines) {
        if (error) {
            err_and_exit('Error loading servers file: %s', err.toString());
            return;
        }

        var total = lines.length;
        var changes = [];
        var done = 0;

        try {
            lines.forEach(function (line) {
                if (line === '\\.') {
                    throw 'break';
                }

                var pieces = line.split('\t').map(function(p) {
                    return p !== '\\N' ? p : '';
                });

                if (pieces.length !== 29) {
                    return;
                }

                var uuid = pieces[16];
                var change = {
                    hostname: pieces[1],
                    reserved: pieces[6] === 't' ? 'true' : 'false',
                    uuid: pieces[16],
                    headnode: pieces[17] === 't' ? 'true' : 'false',
                    last_boot: pieces[18],
                    status: pieces[24],
                    hardware_uuid: pieces[25],
                    boot_args: pieces[26] || '{}',
                    datacenter: datacenter,
                    last_updated: pieces[21],
                    objectclass: 'server'
                };

                changes.push(change);
            });
        } catch (e) {
            if (e !== 'break') throw e;
        }

        callback(changes);
    });
}


function process_package_line(uuid, pieces, errs) {
    var id = pieces[0];

    var pkg = {
        dn: 'uuid=' + uuid + ', ou=packages, o=smartdc',
        uuid: uuid,
        active: (pieces[15] !== '\\N') ? 'true' : 'false',
        cpu_cap: pieces[5],
        'default': pieces[10] !== 'f',
        max_lwps: pieces[6],
        max_physical_memory: pieces[2],
        max_swap: pieces[4],
        name: pieces[1],
        quota: pieces[3],
        urn: pieces[14],
        vcpus: pieces[16],
        version: pieces[13],
        zfs_io_priority: pieces[12],
        objectclass: 'sdcpackage'
    };

    if (pieces[11] !== '\\N') {
        pkg.owner_uuid = pieces[11];
    }

    if (pkg.owner_uuid === null) {
        delete pkg.owner_uuid;
    }

    PACKAGES[id] = pkg;
    //console.log(JSON.stringify(pkg, null, 2));
}


/**
 * 0 -- id
 * 1 -- name
 * 2 -- ram
 * 3 -- disk
 * 4 -- swap
 * 5 -- cpu_cap
 * 6 -- lightweight_processes
 * 7 -- created_at
 * 8 -- udpated_at
 * 9 -- blocked_outgoing_ports
 * 10 -- default
 * 11 -- restricted_to_uuid
 * 12 -- zfs_io_priority
 * 13 -- version
 * 14 -- urn
 * 15 -- deactivated_at
 * 16 -- vcpus
 * */
function transform_packages(file, callback) {
    PACKAGES = {};

    return read_lines(file, function (err, lines) {
        if (err) {
            return callback(err);
        }

        var errs = [];

        lines.forEach(function (line) {
            var pieces = line.split('\t').map(function (e) {
                return e === NULL ? null : e;
            });

            if (pieces.length !== 17) {
                return;
            }

            generate_uuid(function (err, uuid) {
                if (err) {
                    errs.push(err);
                } else {
                    process_package_line(uuid, pieces, errs);
                }
            });
        });

        // Will wait for latest pkg to process, given that line will take
        // way longer to get processed than lines from where we are returning:
        setTimeout(function () {
            if (errs.length !== 0) {
                return callback(errs);
            }

            return callback();
        }, 500);
    });
}

function obj2ldif(obj) {
    var out = '';
    Object.keys(obj).forEach(function (k) {
        if (Array.isArray(obj[k])) {
            out += k + ': ' + JSON.stringify(obj[k]) + '\n';
        } else {
            out += k + ': ' + obj[k] + '\n';
        }
    });
    return out;
}

/**
 * 0 -- id
 * 1 -- package_id
 * 2 -- created_at
 * 3 -- updated_at
 * 4 -- data
 */
// data member will have the following format:
// {
//      "list":[
//          {"networkable_id":2,"networkable_type":"Network"}
//      ],
//      "primary":{"networkable_id":2,"networkable_type":"Network"}
// }
function transform_package_network_list(file, callback) {
    return read_lines(file, function (err, lines) {
        if (err) {
            return callback(err);
        }

        var errs = [];

        lines.forEach(function (line) {
            var pieces = line.split('\t').map(function (e) {
                return e === NULL ? null : e;
            });

            if (pieces.length !== 5) {
                return;
            }

            var pkg = PACKAGES[pieces[1]];
            var networks;

            if (!pkg) {
                return;
            }

            if (!pkg.networks) {
                pkg.networks = [];
            }

            try {
                networks = JSON.parse(pieces[4]).list;
            } catch (e) {
                return;
            }

            networks.forEach(function (net) {
                if (net.networkable_type === 'Network') {
                    var network = NETWORKS[net.networkable_id];
                    if (network) {
                        pkg.networks.push(network.uuid);
                        // If we have package ownership, we need to add this
                        // to the network.
                        if (pkg.owner_uuid) {
                            if (network.owner_uuids &&
                                (network.owner_uuids.indexOf(pkg.owner_uuid) === -1)) {
                                network.owner_uuids.push(pkg.owner_uuid);
                            } else {
                                network.owner_uuids = [pkg.owner_uuid];
                            }
                        }
                    }
                }
            });
        });

        if (errs.length !== 0) {
            return callback(errs);
        }

        var pkgs = [];
        Object.keys(PACKAGES).forEach(function (p) {
            pkgs.push(obj2ldif(PACKAGES[p]));
        });
        fs.writeFile(directory + '/mapi-ufds.ldif',
            (pkgs.join('\n') + '\n'), 'utf8', callback);

    });
}


///--- Mainline

process_argv();

// We do this here because many other transform function might need these
// values
SERVERS = transform_uuids('servers');
VMS = transform_vm_uuids('vms');
ZONES = transform_vm_uuids('zones');

function can_transform_vms() {
    var file;
    var tables = ['datasets', 'zfs_storage_pools', 'tags'];

    for (var i in tables) {
        file = directory + '/' + tables[i] + '.dump';
        if (!existsSync(file)) {
            return false;
        }
    }
    // Try loading this when paths exist
    IMAGES = transform_uuids('datasets');
    ZPOOLS = transform_uuids('zfs_storage_pools');
    TAGS = transform_tags('tags');
    return true;
}


var cur;
var types = [
    ['vms', transform_vms ],
    ['zones', transform_vms ],
    ['nic_tags', transform_nic_tags ],
    ['networks', transform_networks ],
    ['packages', transform_packages ],
    ['package_network_lists', transform_package_network_list ],
    ['subnets', transform_subnets ],
    ['network_ips', transform_network_ips ],
    ['nic_nic_tags', transform_nic_nic_tags ],
    ['nics', transform_nics ],
    ['ips', transform_ips ],
    ['network_pool_networks', transform_network_pool_networks ],
    ['network_pools', transform_network_pools ]
];

function processNextDump(err) {
    if (err) {
        if (err.length) {
            console.error('Errors importing "%s":', cur[0]);
            err.forEach(function (e) {
                console.error('  ' + e.message);
            });
        } else {
            console.error('Error importing "%s": %s', cur[0], err.message);
        }
        close_files();
        process.exit(1);
    }

    cur = types.shift();
    if (!cur) {
        console.log('== done');
        close_files();
        return;
    }
    var file = directory + '/' + cur[0] + '.dump';
    existe(file, function (exists) {
        if (!exists) {
            console.error('Dump file does not exist: %s', file);
            close_files();
            process.exit(1);
        }

        process.nextTick(function () {
            console.log('== ' + cur[0]);
            cur[1](file, processNextDump);
        });
    });
}

processNextDump();
