#!/bin/bash
#
# Copyright (c) 2010,2011 Joyent Inc., All rights reserved.
#

#
# We set errexit (a.k.a. "set -e") to force an exit on error conditions, but
# there are many important error conditions that this does not capture --
# first among them failures within a pipeline (only the exit status of the
# final stage is propagated).  To exit on these failures, we also set
# "pipefail" (a very useful option introduced to bash as of version 3 that
# propagates any non-zero exit values in a pipeline).
#

#export PS4='+(${BASH_SOURCE}:${LINENO}): ${SECONDS} ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
#set -o xtrace

set -o errexit
set -o pipefail

# write output to log file
ROOT=$(cd $(dirname $0)/../; pwd)
LOGDIR="${ROOT}/log"
LOGFILE="${LOGDIR}/build.log.$(date +%Y-%m-%d-%H-%M-%S).$$"
mkdir -p log
exec > >(tee ${LOGFILE}) 2>&1

# 2>&1
echo ">> Starting build at $(date)"

function fatal
{
    echo "$(basename $0): fatal error: $*"
    exit 1
}

function errexit
{
    [[ $1 -ne 0 ]] || exit 0
    fatal "error exit status $1 at line $2"
}

function check_nodejs
{
    if [[ $(echo '{"foo": "bar"}' | ${ROOT}/bin/json foo) == 'bar' ]]; then
        echo "Your version of node.js is ok!"
    else
        fatal "You need to have a working node.js installed for this to work!"
    fi
}

trap 'errexit $? $LINENO' EXIT

STAGE="${ROOT}/cache/stage"
ERROR=0
CLEANED=0
MASTER_PLATFORM_URL="https://guest:GrojhykMid@coal.joyent.us/coal/live_147"

if [ -z "${PLATFORM_URL}" ]; then
    PLATFORM_URL=${MASTER_PLATFORM_URL}
fi
ASSETS_ROOT="https://guest:GrojhykMid@assets.joyent.us/datasets"
PKGSRC_ROOT="http://pkgsrc.joyent.com/2010Q3/All"

# Figure out first what we're building, and load the proper include

PLATFORM=$(uname -s)
BUILD_TYPE=$1
if [[ -z ${BUILD_TYPE} ]]; then
    BUILD_TYPE="vmware"
fi
if [[ ${PLATFORM} == 'Darwin' ]]; then
    case ${BUILD_TYPE} in
        vmware)
            source ${ROOT}/bin/include-vmware-osx
            version
            ;;
        usb)
            source ${ROOT}/bin/include-usb-osx
            version
            ;;
        *)
            fatal  "FATAL: Unsupported build type on OSX: ${BUILD_TYPE}"
            ;;
    esac
elif [[ ${PLATFORM} == 'Linux' ]]; then
    case ${BUILD_TYPE} in
        vmware)
            source ${ROOT}/bin/include-vmware-linux
            version
            ;;
        usb)
            echo "Linux-usb";
            exit 0
            ;;
        *)
            fatal "FATAL: Unsupported build type on Linux: ${BUILD_TYPE}"
            ;;
    esac
elif [[ ${PLATFORM} == 'SunOS' ]]; then
    case ${BUILD_TYPE} in
        usb)
            fatal "FATAL: SmartOS not yet supported for USB key generation"
            ;;
        *)
            fatal "FATAL: Unsupported build type on SmartOS: ${BUILD_TYPE}"
            ;;
    esac
else
    echo "FATAL: Unsupported platform '${PLATFORM}'"
fi

echo -n "==> Checking for Internets... "
if ! can_has_internets; then
    echo "No Internets! Activating countermeasures!"
    HAVE_INTERNET="false"
else
    echo "Yep!"
    HAVE_INTERNET="true"
fi

function test_rootperms
{
    su_uid=$(${SUCMD} id -u)
    if [[ ${su_uid} -ne 0 ]]; then
        fatal "Can't get root priviledges."
    fi
}

function load_buildspec
{
    if [[ -f "${ROOT}/build.spec.local" ]]; then
        PLATFORM_RELEASE=$(cat ${ROOT}/build.spec.local \
            | ${ROOT}/bin/json platform-release)
        BUILD_TGZ=$(cat ${ROOT}/build.spec.local \
            | ${ROOT}/bin/json build-tgz)
        echo "platform-release: ${PLATFORM_RELEASE}"
    elif [[ -f "${ROOT}/build.spec" ]]; then
        PLATFORM_RELEASE=$(cat ${ROOT}/build.spec \
            | ${ROOT}/bin/json platform-release)
        BUILD_TGZ=$(cat ${ROOT}/build.spec \
            | ${ROOT}/bin/json build-tgz)
        echo "platform-release: ${PLATFORM_RELEASE}"
    fi
}

function create_directories
{
    if [ ! -d "${ROOT}/cache" ]; then
        echo "==> Creating cache/"
        mkdir -p ${ROOT}/cache
    fi

    if [ ! -d "${ROOT}/mnt" ]; then
        echo "==> Creating mnt/"
        mkdir -p ${ROOT}/mnt
    fi

    echo "==> Creating stage/"
    rm -rf ${STAGE}
    mkdir -p ${STAGE}
    mkdir -p ${STAGE}/data
}

function copy_base
{
    echo "==> Creating .joyliveusb file"
    touch ${STAGE}/.joyliveusb

    echo "==> Copying in grub menu"
    mkdir -p ${STAGE}/boot/grub
    cp boot/grub/menu.lst ${STAGE}/boot/grub/menu.lst
    cp boot/grub/stage2 ${STAGE}/boot/grub/stage2
    cp boot/splash.xpm.gz ${STAGE}/boot/splash.xpm.gz

    echo "==> Copying in config"
    if [[ -n ${IMG_TYPE} ]] && [[ "${IMG_TYPE}" == "coal" ]]; then
        if [[ -f config/config.coal.local ]]; then
          cp config/config.coal.local ${STAGE}/config
        else
          cp config/config.coal ${STAGE}/config
        fi
        cp -r config/config.coal.inc ${STAGE}/config.inc
    else
        if [[ -f config/config.usb.local ]]; then
          cp config/config.usb.local ${STAGE}/config
        else
          cp config/config.usb ${STAGE}/config
        fi
        cp -r config/config.usb.inc ${STAGE}/config.inc
    fi

    echo "==> Copying in scripts/"
    cp -r scripts ${STAGE}/scripts

    echo "==> Copying in zoneinit/"
    cp -r zoneinit ${STAGE}/zoneinit

    echo "==> Copying in zones/"
    cp -r zones ${STAGE}/zones
}

function copy_pkgsrc
{
    if [[ ${HAVE_INTERNET} == "true" ]]; then
        (cd ${ROOT}/cache \
            && rm -f md5sums.txt \
            && curl --progress-bar -O ${PKGSRC_ROOT}/md5sums.txt) \
            || fatal "Failed to download ${PKGSRC_ROOT}/md5sums.txt"
    elif [[ ! -f ${ROOT}/cache/md5sums.txt ]]; then
        fatal "Don't have cached md5sums.txt file, can't build. " \
            "You need to find some Internet."
    fi
    pkgs=$(cat ${ROOT}/zones/*/pkgsrc \
        | xargs -n1 \
        | sort \
        | uniq \
        | sed -e "s/$/.tgz/")
    for pkgfile in $pkgs; do
        MD5=$(grep " ${pkgfile}" ${ROOT}/cache/md5sums.txt | cut -d' ' -f1)
        if [[ -z ${MD5} ]]; then
            fatal "Unable to find md5sum for ${pkgfile}, " \
                "must be fixed before we can continue."
        fi

        [[ -f ${ROOT}/cache/${pkgfile} ]] \
            && ACTUAL_MD5=$(${MD5CMD} ${ROOT}/cache/${pkgfile} | cut -d' ' -f1)

        if [[ ! -f ${ROOT}/cache/${pkgfile} ]] \
            || [[ -z ${ACTUAL_MD5} ]] \
            || [[ ${MD5} != ${ACTUAL_MD5} ]]; then

            echo "==> Downloading ${pkgfile}"
            # if this exists, it's corrupt
            rm -f ${ROOT}/cache/${pkgfile}
            if [[ ${HAVE_INTERNET} == "true" ]]; then
                (cd ${ROOT}/cache \
                    && curl --progress-bar -k -fO ${PKGSRC_ROOT}/${pkgfile}) \
                    || fatal "could not download ${PKGSRC_ROOT}/${pkgfile}"
            else
                fatal "Need Internet to download ${pkgfile}"
            fi
        else
            echo "==> Not downloading ${pkgfile} as existing file matches MD5"
        fi
    done

    echo "==> Creating pkgsrc.tar"
    (cd ${ROOT}/cache && tar -cvf ${STAGE}/data/pkgsrc.tar ${pkgs})
}

function valid_tgz_archive
{
    filename=$1
    if [[ -f ${filename} ]] && tar -ztf ${filename} > /dev/null; then
        return 0
    else
        return 1
    fi
}

function valid_archive
{
    filename=$1
    if [[ -f ${filename} ]] && tar -tf ${filename} > /dev/null; then
        return 0
    else
        return 1
    fi
}

function copy_platform
{
    [[ -z "${loops}" ]] && loops=0
    loops=$((${loops} + 1))
    [[ ${loops} -gt 2 ]] && fatal "Unable to download platform, looping!"

    valid_platform="false"
    if [ -z $PLATFORM_FILE ]; then
        if [[ ${HAVE_INTERNET} == "true" ]]; then
            if [[ -n "${PLATFORM_RELEASE}" ]]; then
                latest_image=$(curl -k -sS ${PLATFORM_URL}/ \
                    | grep "href=\"platform-${PLATFORM_RELEASE}-[0-9]" \
                    | cut -d'"' -f2 | sort | tail -n 1)
            else
                latest_image=$(curl -k -sS ${PLATFORM_URL}/ \
                    | grep "href=\"platform-[0-9]" \
                    | cut -d'"' -f2 | sort | tail -n 1)
            fi

            if [[ ! -f "${ROOT}/cache/${latest_image}" ]]; then
                echo "==> Downloading ${latest_image}"
                (cd ${ROOT}/cache \
                  && curl --progress-bar -k -O ${PLATFORM_URL}/${latest_image}) \
                  || fatal "Unable to download ${PLATFORM_URL}/${latest_image}"
            fi
        else
            latest_image=$(cd ${ROOT}/cache && ls platform-*.tgz | head)
            if [[ -z ${latest_image} ]]; then
                fatal "Unable to find a platform image and we have no Internet."
            fi
        fi

        image=${ROOT}/cache/${latest_image}
        if [[ -f ${image} ]] && ! valid_archive ${image}; then
            echo "Removing corrupt ${image}"
            rm -f ${image}
            image=
            # unset image and try again
            copy_platform
        fi
    else
        image=${PLATFORM_FILE}
        echo "==> Using ${image} as platform image"
        if ! valid_archive "${image}"; then
            fatal "Refusing to use corrupt platform ${image}"
        fi
    fi

    echo "==> Unpacking `basename ${image}`"
    (cd ${STAGE}/; tar -zxf ${image}; mv platform-* platform) \
        || fatal "Unable to unpack platform"
    if [[ -f ${STAGE}/platform/root.password ]]; then
        (cd ${STAGE}/ \
            && mkdir -p private \
            && mv -f platform/root.password private/) \
            || fatal "Unable to move root.password"
    fi
    echo "Root password is: '$(cat ${STAGE}/private/root.password)'"
    LIVEIMG_VERSION=`basename ${image} \
        | sed -e "s/platform.*-\([0-9TZ]*\)\.tgz/\1/"`

    # Rename log file here since we know the buildstamp now
    mv ${LOGFILE} ${LOGDIR}/build.log.${LIVEIMG_VERSION}
    LOGFILE="${LOGDIR}/build.log.${LIVEIMG_VERSION}"

    loops=
}

function copy_agents
{
    [[ -z "${loops}" ]] && loops=0
    loops=$((${loops} + 1))
    [[ ${loops} -gt 2 ]] && fatal "Unable to download agents, looping!"

    # See if there's a specific agents we're supposed to use
    if [[ -f ${ROOT}/build.spec.local ]]; then
        agents_shar=$(cat ${ROOT}/build.spec.local \
            | ${ROOT}/bin/json agents-shar)
    elif [[ -f ${ROOT}/build.spec ]]; then
        agents_shar=$(cat ${ROOT}/build.spec \
            | ${ROOT}/bin/json agents-shar)
    fi
    if [[ -z ${agents_shar} ]]; then
        agents_shar="latest"
    fi

    # Figure out for sure which one we want
    if [[ ${agents_shar} == "latest" ]]; then
        if [[ ${HAVE_INTERNET} == "true" ]]; then
            latest_agents=$(curl -k -sS ${MASTER_PLATFORM_URL}/ur-scripts/ \
                | grep "href=\"agents" | cut -d'"' -f2 | sort | tail -n 1)
        else
            latest_agents=$(cd ${ROOT}/cache && ls agents-*.sh | head)
        fi
        if [[ -z ${latest_agents} ]]; then
            fatal "Unable to find latest agents!"
        fi
        use_agents=${latest_agents}
    else
        # we've got a specific set of agents specified, use those
        use_agents=${agents_shar}
    fi

    if [[ -z ${use_agents} ]]; then
        fatal "Unable to determine which agents to use!"
    fi

    echo "Using agents: [${use_agents}]"

    if [[ ! -f "${ROOT}/cache/${use_agents}" ]] \
        || [[ ! -f "${ROOT}/cache/`basename ${use_agents} .sh`.md5sum" ]]; then
        if [[ ${HAVE_INTERNET} == "true" ]]; then
            echo "==> Downloading ${use_agents}"

            AGENT_URL_BASE="${MASTER_PLATFORM_URL}/ur-scripts"
            AGENT_URL="${AGENT_URL_BASE}/${use_agents}"
            AGENT_MD_URL="${AGENT_URL_BASE}/`basename ${use_agents} .sh`.md5sum"

            (cd ${ROOT}/cache && curl --progress-bar -k -O ${AGENT_URL}) \
                || fatal "Unable to download ${AGENT_URL}"
            (cd ${ROOT}/cache && curl --progress-bar -k -O ${AGENT_MD_URL}) \
                || fatal "Unable to download ${AGENT_MD_URL}"
        else
            fatal "Don't have required '${use_agents}' " \
                "and can't download (no Internet)"
        fi
    fi

    mkdir -p ${STAGE}/ur-scripts

    # Make sure it's not corrupt
    if [[ -n "${use_agents}" ]] \
        && [[ -f "${ROOT}/cache/${use_agents}" ]] \
        && [[ -f "${ROOT}/cache/`basename ${use_agents} .sh`.md5sum" ]]; then

        # Check the md5sum
        MD5=$(cat ${ROOT}/cache/`basename ${use_agents} .sh`.md5sum)
        ACTUAL_MD5=$(${MD5CMD} ${ROOT}/cache/${use_agents} | cut -d' ' -f1)

        if [[ -z ${MD5} ]] \
            || [[ -z ${ACTUAL_MD5} ]] \
            || [[ ${MD5} != ${ACTUAL_MD5} ]]; then

            echo "Removing corrupt ${use_agents}"
            rm -f ${ROOT}/cache/${use_agents} \
                ${ROOT}/cache/`basename ${use_agents} .sh`.md5sum
            use_agents=
            copy_agents
        fi

        echo "==> Copying ${use_agents}"
        cp ${ROOT}/cache/${use_agents} ${STAGE}/ur-scripts/${use_agents}
    fi

    loops=
}

# Called to get the magic missing bits from the nodejs dataset
function get_node_magic
{
    [[ -z "${loops}" ]] && loops=0
    loops=$((${loops} + 1))
    [[ ${loops} -gt 2 ]] && fatal "Unable to download nodejs magic, looping!"

    valid_magic="false"
    if [[ ${HAVE_INTERNET} == "true" ]]; then
        NODE_SERVICE_RELEASES="${MASTER_PLATFORM_URL}/node"
        latest_release=$(curl -k -sS ${NODE_SERVICE_RELEASES}/ \
            | grep "href=\"node_service-*" | cut -d'"' -f2 | sort | tail -n 1)

        if [[ ! -f "${ROOT}/cache/${latest_release}" ]]; then
            echo "==> Downloading ${latest_release}"
            (cd ${ROOT}/cache \
                && curl --progress-bar -k \
                -O ${NODE_SERVICE_RELEASES}/${latest_release}) \
                || fatal "Unable to download ${latest_release}"
        fi
    else
        latest_release=$(cd ${ROOT}/cache && ls node_service-*.tgz | head)
        if [[ -z ${latest_release} ]]; then
            fatal "Unable to find a node_service magicball " \
                "and we have no Internet."
        fi
    fi

    magicball=${ROOT}/cache/${latest_release}
    if [[ -f ${magicball} ]] && ! valid_tgz_archive ${magicball}; then
        echo "Removing corrupt ${magicball}"
        rm -f ${magicball}
        # unset and try again
        magicball=
        get_node_magic
    fi

    # if we get here, we should have the file and it's valid!
    cp ${magicball} ${STAGE}/datasets/

    loops=
}

function copy_datasets
{
    datasets=( bare-1.2.8 protemplate-2.5.2 nodejs-0.4.0 )
    mkdir -p  ${STAGE}/datasets
    for dataset in ${datasets[@]}
    do
        dataset_file="${dataset}.zfs.bz2"
        if ! bzip2 -t ${ROOT}/cache/${dataset_file}; then
            echo "==> Corrupt ${dataset_file}, deleting..."
            rm -f ${ROOT}/cache/${dataset_file}
        fi

        if [[ ! -f ${ROOT}/cache/${dataset_file} ]]; then
            if [[ ${HAVE_INTERNET} == "true" ]]; then
                echo "==> Downloading ${dataset_file}"
                (cd ${ROOT}/cache && curl --progress-bar -k \
                    -O ${ASSETS_ROOT}/${dataset_file}) \
                    || fatal "Unable to download ${dataset_file}"
            else
                fatal "Don't have Internet, and don't have valid " \
                    "${dataset_file}. Can't build."
            fi
        fi

        if ! bzip2 -t ${ROOT}/cache/${dataset_file}; then
            rm -f ${ROOT}/cache/${dataset_file}
            fatal "Corrupt ${dataset_file}, deleted! Try build again."
        fi

        echo "==> Copying ${dataset_file}"
        cp ${ROOT}/cache/${dataset_file} ${STAGE}/datasets/${dataset_file}

        if [[ ${dataset} == "nodejs-0.4.0" ]]; then
            # the nodejs-0.4.0 dataset is magical and "special" so it needs
            # more stuff
            get_node_magic
        fi
    done
}

function copy_zones
{
    for zone in $(ls ${STAGE}/zones); do

        fsuri=${STAGE}/zones/${zone}/fs.uri

        if [ ! -f $fsuri ]; then
            continue
        fi

        #
        # We allow the fs.uri file to be overridden with a [zone]_FS variable
        # (e.g., "RABBITMQ_FS"), which must contain a bzip2'd tar file.
        #
        local override=$(echo $zone | tr '[:lower:]' '[:upper:]')_FS

        if [[ -n "${!override}" ]]; then
            file=${!override}

            if [[ ! -f ${file} ]]; then
                fatal "expected a file for $override"
            fi

            if ( ! file ${file} | grep bzip2 > /dev/null ); then
                fatal "expected a bzip2'd tar file for $override"
            fi

            mkdir -p ${STAGE}/zones/${zone}
            echo "==> Using \$${override} (${file}) for ${zone} zone"
            cp ${file} ${STAGE}/zones/${zone}/fs.tar.bz2
            continue
        fi

        #
        # If we have an fs.uri file, it should be a URI indicating a bzip2'd tar
        # file; check that the suffix is either ".tbz2" or ".tar.bz2".
        #
        uri=`cat $fsuri`
        suffix=${uri##*.}

        if [ "$suffix" != "tbz2" ]; then
            prefix=${uri%.*}
            if [ $suffix != "bz2" ] || [ ${prefix##*.} != "tar" ]; then
                fatal "$zone: illegal fs.uri: $uri (expected bzip2\'d tarball)"
            fi
        fi

        #
        # If the path has no subdirectory components, then we'll fetch the
        # file from ${ASSETS_ROOT}.
        #
        if [ ${uri%%/*} == $uri ]; then
            uri=${ASSETS_ROOT}/liveimg/${uri}
        fi

        file=${uri##*/}

        if [[ -f ${ROOT}/cache/${file} ]] \
            && ! bzip2 -t ${ROOT}/cache/${file}; then

            echo "Corrupt ${file}, deleting..."
            rm -f ${ROOT}/cache/${file}
        fi

        if [[ ${HAVE_INTERNET} == "true" ]]; then
            echo "==> Updating ${file}"
            CURL_OPTS=
            [[ -f ${ROOT}/cache/${file} ]] \
                && CURL_OPTS="-z ${ROOT}/cache/${file}"
            (cd ${ROOT}/cache \
                && curl --progress-bar -k ${CURL_OPTS} -fO $uri) \
                || fatal "could not download $uri for $zone"
        elif [[ ! -f ${ROOT}/cache/${file} ]]; then
            fatal "Don't have Internet and don't have ${file}. Can't build."
        fi

        mkdir -p ${STAGE}/zones/${zone}
        cp ${ROOT}/cache/${file} ${STAGE}/zones/${zone}/fs.tar.bz2
    done

    for zone in $(ls ${STAGE}/zones); do

        # See if there's a specific branch we should use (default to 'develop')
        if [[ -f ${ROOT}/build.spec.local ]]; then
            CHECKOUT_TARGET=$(cat ${ROOT}/build.spec.local \
                | ${ROOT}/bin/json "${zone}-branch")
        elif [[ -f ${ROOT}/build.spec ]]; then
            CHECKOUT_TARGET=$(cat ${ROOT}/build.spec \
                | ${ROOT}/bin/json "${zone}-branch")
        fi
        [[ -z ${CHECKOUT_TARGET} ]] && CHECKOUT_TARGET='origin/develop'
        export CHECKOUT_TARGET

        if [ -x ${STAGE}/zones/${zone}/fs.populate ] && \
          [ -d ${STAGE}/zones/${zone}/fs.root ]; then
            # do in /tmp because only root can write in mnt
            mkdir -p /tmp/fs.${zone}.$$
            cp -pPR ${STAGE}/zones/${zone}/fs.populate \
                ${STAGE}/zones/${zone}/fs.root /tmp/fs.${zone}.$$
            rm -rf ${STAGE}/zones/${zone}/fs.{populate,root}
            (cd /tmp/fs.${zone}.$$/fs.root \
                && ../fs.populate \
                && tar -jcvf ${STAGE}/zones/${zone}/fs.tar.bz2 ./)
            if [[ $? -ne 0 ]]; then
                fatal "Failed to populate fs.tar.bz2 for ${zone}"
            fi
        fi

        if [[ "${IMG_TYPE}" == "coal" ]]; then
          echo "IMG_TYPE=coal" >> ${STAGE}/zones/${zone}/zoneconfig
        fi
    done
}

function copy_devtools
{
    if [[ "${IMG_TYPE}" == "coal" ]]; then
        echo "==> Copying in devtools"
        cp -r ${ROOT}/devtools ${STAGE}/devtools
    fi
}

function copy_to_mount
{
    (cd ${STAGE} && tar ${TAR_ROOT} -cf - ./) \
        | (cd ${MNT_DIR} && ${SUCMD} tar -xvf -) \
        || fatal "Unable to copy files to mount"
}

# Main()

check_nodejs
test_rootperms
create_directories
load_buildspec
copy_base
copy_pkgsrc
copy_platform
copy_agents
copy_datasets
copy_zones
copy_devtools
unpack_image
add_manifests
mount_image
trap 'cleanup' EXIT
copy_to_mount
cleanup
create_output

# Unfortunately the log contains a whole bunch of progress updates,
# clean that up.
if [[ -f ${LOGFILE} ]]; then
    cat ${LOGFILE} | grep -v "" > ${LOGFILE}.tmp \
    && mv ${LOGFILE}.tmp ${LOGFILE}
fi

if [ ${ERROR} -ne 0 ]; then
    fatal "==> SOMETHING WENT WRONG! ERROR: ${ERROR}"
fi

echo "==> DONE"

exit 0
