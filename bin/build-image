#!/bin/bash
#
# Copyright (c) 2010 Joyent Inc., All rights reserved.
#

#
# We set errexit (a.k.a. "set -e") to force an exit on error conditions, but
# there are many important error conditions that this does not capture --
# first among them failures within a pipeline (only the exit status of the
# final stage is propagated).  To exit on these failures, we also set
# "pipefail" (a very useful option introduced to bash as of version 3 that
# propagates any non-zero exit values in a pipeline).
#
set -o errexit
set -o pipefail

function fatal
{
    echo "$(basename $0): fatal error: $*"
    exit 1
}

function errexit
{
    [[ $1 -ne 0 ]] || exit 0
    fatal "error exit status $1 at line $2"
}

trap 'errexit $? $LINENO' EXIT

ROOT=$(cd $(dirname $0)/../; pwd)
STAGE="${ROOT}/cache/stage"
ERROR=0
CLEANED=0
MASTER_PLATFORM_URL="https://guest:GrojhykMid@coal.joyent.us/coal/live_147"

if [ -z "${PLATFORM_URL}" ]; then
    PLATFORM_URL=${MASTER_PLATFORM_URL}
fi
ASSETS_ROOT="https://guest:GrojhykMid@assets.joyent.us/templates"
PKGSRC_ROOT="http://pkgsrc.joyent.com/2010Q3/All"

# Figure out first what we're building, and load the proper include

PLATFORM=$(uname -s)
BUILD_TYPE=$1
if [[ -z ${BUILD_TYPE} ]]; then
    BUILD_TYPE="vmware"
fi
if [[ ${PLATFORM} == 'Darwin' ]]; then
    case ${BUILD_TYPE} in
        vmware)
            source ${ROOT}/bin/include-vmware-osx
            version
            ;;
        usb)
            source ${ROOT}/bin/include-usb-osx
            version
            ;;
        *)
            echo "FATAL: Unsupported build type on OSX: ${BUILD_TYPE}"
            exit 1
            ;;
    esac
elif [[ ${PLATFORM} == 'Linux' ]]; then
    case ${BUILD_TYPE} in
        vmware)
            source ${ROOT}/bin/include-vmware-linux
            version
            ;;
        usb)
            echo "Linux-usb";
            exit 0
            ;;
        *)
            echo "FATAL: Unsupported build type on Linux: ${BUILD_TYPE}"
            exit 1
            ;;
    esac
elif [[ ${PLATFORM} == 'SunOS' ]]; then
    case ${BUILD_TYPE} in
        usb)
            echo "FATAL: SmartOS not yet supported for USB key generation"
            exit 1
            ;;
        *)
            echo "FATAL: Unsupported build type on SmartOS: ${BUILD_TYPE}"
            exit 1
            ;;
    esac
else
    echo "FATAL: Unsupported platform '${PLATFORM}'"
fi

function test_rootperms
{
    su_uid=$(${SUCMD} id -u)
    if [[ ${su_uid} -ne 0 ]]; then
        echo "FATAL: can't get root priviledges"
        exit 1
    fi
}

function create_directories
{
    if [ ! -d "${ROOT}/cache" ]; then
        echo "==> Creating cache/"
        mkdir -p ${ROOT}/cache
    fi

    if [ ! -d "${ROOT}/mnt" ]; then
        echo "==> Creating mnt/"
        mkdir -p ${ROOT}/mnt
    fi

    echo "==> Creating stage/"
    rm -rf ${STAGE}
    mkdir -p ${STAGE}
    mkdir -p ${STAGE}/data
}

function copy_base
{
    echo "==> Creating .joyliveusb file"
    touch ${STAGE}/.joyliveusb

    echo "==> Copying in grub menu"
    mkdir -p ${STAGE}/boot/grub
    cp boot/grub/menu.lst ${STAGE}/boot/grub/menu.lst

    echo "==> Copying in config"
    if [[ -n ${IMG_TYPE} ]] && [[ "${IMG_TYPE}" == "coal" ]]; then
        if [[ -f config/config.coal.local ]]; then
          cp config/config.coal.local ${STAGE}/config
        else
          cp config/config.coal ${STAGE}/config
        fi
        cp -r config/config.coal.inc ${STAGE}/config.inc
    else
        if [[ -f config/config.usb.local ]]; then
          cp config/config.usb.local ${STAGE}/config
        else
          cp config/config.usb ${STAGE}/config
        fi
        cp -r config/config.usb.inc ${STAGE}/config.inc
    fi

    echo "==> Copying in scripts/"
    cp -r scripts ${STAGE}/scripts

    echo "==> Copying in zoneinit/"
    cp -r zoneinit ${STAGE}/zoneinit

    echo "==> Copying in zones/"
    cp -r zones ${STAGE}/zones
}

function copy_pkgsrc
{
    pkgs=$(cat ${ROOT}/zones/*/pkgsrc | xargs -n1 | sort | uniq | sed -e "s/$/.tgz/")
    for pkgfile in $pkgs; do
            echo "==> Downloading ${pkgfile}"
            CURL_OPTS=
            [[ -f ${ROOT}/cache/${pkgfile} ]] && \
                CURL_OPTS="-z ${ROOT}/cache/${pkgfile}"

            (cd ${ROOT}/cache && curl --progress-bar \
                -k ${CURL_OPTS} -fO ${PKGSRC_ROOT}/${pkgfile}) || \
                fatal "could not download ${PKGSRC_ROOT}/${pkgfile}"
    done

    echo "==> Creating pkgsrc.tar"
    (cd ${ROOT}/cache && tar -cvf ${STAGE}/data/pkgsrc.tar ${pkgs})
}

function copy_platform
{
    if [ -z $PLATFORM_FILE ]; then
        latest_image=$(curl -k -sS ${PLATFORM_URL}/ \
            | grep "href=\"platform" | cut -d'"' -f2 | sort | tail -n 1)
        if [ ! -f "${ROOT}/cache/${latest_image}" ]; then
            echo "==> Downloading ${latest_image}"
            (cd ${ROOT}/cache && \
              curl --progress-bar -k -O ${PLATFORM_URL}/${latest_image})
        fi

        # TODO: also check md5sum before using!
        image=${ROOT}/cache/${latest_image}
    else
        image=$PLATFORM_FILE
        echo "==> Using ${image} as platform image"
    fi

    echo "==> Unpacking `basename ${image}`"
    (cd ${STAGE}/ && tar -zxf ${image} && mv platform-* platform)
    if [[ -f ${STAGE}/platform/root.password ]]; then
        (cd ${STAGE}/ && mkdir -p private && mv -f platform/root.password private/)
    fi
    LIVEIMG_VERSION=`basename ${image} | sed -e "s/platform-\(.*\)\.tgz/\1/"`
}

function copy_agents
{
    # Grab the latest agent ur-script too
    latest_agents=$(curl -k -sS ${MASTER_PLATFORM_URL}/ur-scripts/ \
        | grep "href=\"agents" | cut -d'"' -f2 | sort | tail -n 1)
    if [ ! -f "${ROOT}/cache/${latest_agents}" ]; then
        echo "==> Downloading ${latest_agents}"
        (cd ${ROOT}/cache && curl --progress-bar -k -O ${MASTER_PLATFORM_URL}/ur-scripts/${latest_agents})
    fi
    mkdir -p ${STAGE}/ur-scripts
    cp ${ROOT}/cache/${latest_agents} ${STAGE}/ur-scripts/${latest_agents}
}

function copy_datasets
{
    datasets=( bare-1.2.8 protemplate-2.5.2 nodejs147-0.3.0 )

    for dataset in ${datasets[@]}
    do
        dataset_file="${dataset}.zfs.gz"
        basename=$(echo ${dataset} | cut -d'-' -f1)
        echo "==> Downloading ${dataset_file}"
        CURL_OPTS=
        [[ -f ${ROOT}/cache/${dataset_file} ]] && CURL_OPTS="-z ${ROOT}/cache/${dataset_file}"
        (cd ${ROOT}/cache && curl --progress-bar -k ${CURL_OPTS} -O ${ASSETS_ROOT}/${dataset_file})
        md5=$(${MD5CMD} ${ROOT}/cache/${dataset_file} | cut -d' ' -f1)

        if [[ ! -f ${ROOT}/cache/${dataset}.${md5}.bz2 ]]; then
            echo "==> Repacking ${dataset_file}"
            ${GZCAT} ${ROOT}/cache/${dataset_file} | bzip2 -9 > "${ROOT}/cache/${dataset}.${md5}.bz2"
        fi

        echo "==> Copying ${dataset}.zfs.bz2"
        cp ${ROOT}/cache/${dataset}.${md5}.bz2 ${STAGE}/${basename}.zfs.bz2
    done
}

function copy_zones
{
    for zone in $(ls ${STAGE}/zones); do
        fsuri=${STAGE}/zones/${zone}/fs.uri

        if [ ! -f $fsuri ]; then
            continue
        fi

        #
        # We allow the fs.uri file to be overridden with a [zone]_FS variable
        # (e.g., "RABBITMQ_FS"), which must contain a bzip2'd tar file.
        #
        local override=$(echo $zone | tr '[:lower:]' '[:upper:]')_FS

        if [[ -n "${!override}" ]]; then
            file=${!override}

            if [[ ! -f ${file} ]]; then
                fatal "expected a file for $override"
            fi

            if ( ! file ${file} | grep bzip2 > /dev/null ); then
                fatal "expected a bzip2'd tar file for $override"
            fi

            mkdir -p ${STAGE}/zones/${zone}
            echo "==> Using \$${override} (${file}) for ${zone} zone"
            cp ${file} ${STAGE}/zones/${zone}/fs.tar.bz2
            continue
        fi

        #
        # If we have an fs.uri file, it should be a URI indicating a bzip2'd tar
        # file; check that the suffix is either ".tbz2" or ".tar.bz2".
        #
        uri=`cat $fsuri`
        suffix=${uri##*.}

        if [ "$suffix" != "tbz2" ]; then
            prefix=${uri%.*}
            if [ $suffix != "bz2" ] || [ ${prefix##*.} != "tar" ]; then
                fatal "$zone: illegal fs.uri: $uri (expected bzip2\'d tarball)"
            fi
        fi

        #
        # If the path has no subdirectory components, then we'll fetch the
        # file from ${ASSETS_ROOT}.
        #
        if [ ${uri%%/*} == $uri ]; then
            uri=${ASSETS_ROOT}/liveimg/${uri}
        fi

        file=${uri##*/}

        echo "==> Downloading ${file}"
        CURL_OPTS=
        [[ -f ${ROOT}/cache/${file} ]] && CURL_OPTS="-z ${ROOT}/cache/${file}"
        (cd ${ROOT}/cache && curl --progress-bar -k ${CURL_OPTS} -fO $uri) || \
            fatal "could not download $uri for $zone"

        mkdir -p ${STAGE}/zones/${zone}
        cp ${ROOT}/cache/${file} ${STAGE}/zones/${zone}/fs.tar.bz2
    done

    for zone in $(ls ${STAGE}/zones); do
        if [ -x ${STAGE}/zones/${zone}/fs.populate ] && \
          [ -d ${STAGE}/zones/${zone}/fs.root ]; then
            # do in /tmp because only root can write in mnt
            mkdir -p /tmp/fs.${zone}.$$
            cp -pPR ${STAGE}/zones/${zone}/fs.populate ${STAGE}/zones/${zone}/fs.root /tmp/fs.${zone}.$$
            rm -rf ${STAGE}/zones/${zone}/fs.{populate,root}
            (cd /tmp/fs.${zone}.$$/fs.root && ../fs.populate && tar -jcvf ${STAGE}/zones/${zone}/fs.tar.bz2 ./)
        fi

        if [[ "${IMG_TYPE}" == "coal" ]]; then
          echo "IMG_TYPE=coal" >> ${STAGE}/zones/${zone}/zoneconfig
        fi
    done
}

function copy_devtools
{
    if [[ "${IMG_TYPE}" == "coal" ]]; then
        echo "==> Copying in devtools"
        cp -r ${ROOT}/devtools ${STAGE}/devtools
    fi
}

function copy_to_mount
{
    (cd ${STAGE} && tar ${TAR_ROOT} -cf - ./) | (cd ${MNT_DIR} && ${SUCMD} tar -xvf -)
}

# Main()

test_rootperms
create_directories
copy_base
copy_pkgsrc
copy_platform
copy_agents
copy_datasets
copy_zones
copy_devtools
unpack_image
add_manifests
mount_image
trap 'cleanup' EXIT
copy_to_mount
cleanup
create_output

if [ ${ERROR} -ne 0 ]; then
    echo "==> SOMETHING WENT WRONG! ERROR: ${ERROR}"
    exit 1
fi

echo "==> DONE"

exit 0
