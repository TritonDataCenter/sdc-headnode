#!/bin/bash
#
# Copyright (c) 2010,2011 Joyent Inc., All rights reserved.
#

#
# We set errexit (a.k.a. "set -e") to force an exit on error conditions, but
# there are many important error conditions that this does not capture --
# first among them failures within a pipeline (only the exit status of the
# final stage is propagated).  To exit on these failures, we also set
# "pipefail" (a very useful option introduced to bash as of version 3 that
# propagates any non-zero exit values in a pipeline).
#

set -o errexit
set -o pipefail

function fatal
{
    echo "$(basename $0): fatal error: $*"
    exit 1
}

function errexit
{
    [[ $1 -ne 0 ]] || exit 0
    fatal "error exit status $1 at line $2"
}

function can_has_internets
{
    if ping -o -c 5 8.8.8.8 >/dev/null 2>&1 || ping -o -c 5 4.2.2.1 >/dev/null 2>&1; then
        return 0
    fi
    return 1
}

trap 'errexit $? $LINENO' EXIT

echo -n "==> Checking for Internets... "
if ! can_has_internets; then
    echo "No Internets! Activating countermeasures!"
    HAVE_INTERNET="false"
else
    echo "Yep!"
    HAVE_INTERNET="true"
fi

ROOT=$(cd $(dirname $0)/../; pwd)
STAGE="${ROOT}/cache/stage"
ERROR=0
CLEANED=0
MASTER_PLATFORM_URL="https://guest:GrojhykMid@coal.joyent.us/coal/live_147"

if [ -z "${PLATFORM_URL}" ]; then
    PLATFORM_URL=${MASTER_PLATFORM_URL}
fi
ASSETS_ROOT="https://guest:GrojhykMid@assets.joyent.us/templates"
PKGSRC_ROOT="http://pkgsrc.joyent.com/2010Q3/All"

# Figure out first what we're building, and load the proper include

PLATFORM=$(uname -s)
BUILD_TYPE=$1
if [[ -z ${BUILD_TYPE} ]]; then
    BUILD_TYPE="vmware"
fi
if [[ ${PLATFORM} == 'Darwin' ]]; then
    case ${BUILD_TYPE} in
        vmware)
            source ${ROOT}/bin/include-vmware-osx
            version
            ;;
        usb)
            source ${ROOT}/bin/include-usb-osx
            version
            ;;
        *)
            fatal  "FATAL: Unsupported build type on OSX: ${BUILD_TYPE}"
            ;;
    esac
elif [[ ${PLATFORM} == 'Linux' ]]; then
    case ${BUILD_TYPE} in
        vmware)
            source ${ROOT}/bin/include-vmware-linux
            version
            ;;
        usb)
            echo "Linux-usb";
            exit 0
            ;;
        *)
            fatal "FATAL: Unsupported build type on Linux: ${BUILD_TYPE}"
            ;;
    esac
elif [[ ${PLATFORM} == 'SunOS' ]]; then
    case ${BUILD_TYPE} in
        usb)
            fatal "FATAL: SmartOS not yet supported for USB key generation"
            ;;
        *)
            fatal "FATAL: Unsupported build type on SmartOS: ${BUILD_TYPE}"
            ;;
    esac
else
    echo "FATAL: Unsupported platform '${PLATFORM}'"
fi

function test_rootperms
{
    su_uid=$(${SUCMD} id -u)
    if [[ ${su_uid} -ne 0 ]]; then
        fatal "Can't get root priviledges."
    fi
}

function create_directories
{
    if [ ! -d "${ROOT}/cache" ]; then
        echo "==> Creating cache/"
        mkdir -p ${ROOT}/cache
    fi

    if [ ! -d "${ROOT}/mnt" ]; then
        echo "==> Creating mnt/"
        mkdir -p ${ROOT}/mnt
    fi

    echo "==> Creating stage/"
    rm -rf ${STAGE}
    mkdir -p ${STAGE}
    mkdir -p ${STAGE}/data
}

function copy_base
{
    echo "==> Creating .joyliveusb file"
    touch ${STAGE}/.joyliveusb

    echo "==> Copying in grub menu"
    mkdir -p ${STAGE}/boot/grub
    cp boot/grub/menu.lst ${STAGE}/boot/grub/menu.lst

    echo "==> Copying in config"
    if [[ -n ${IMG_TYPE} ]] && [[ "${IMG_TYPE}" == "coal" ]]; then
        if [[ -f config/config.coal.local ]]; then
          cp config/config.coal.local ${STAGE}/config
        else
          cp config/config.coal ${STAGE}/config
        fi
        cp -r config/config.coal.inc ${STAGE}/config.inc
    else
        if [[ -f config/config.usb.local ]]; then
          cp config/config.usb.local ${STAGE}/config
        else
          cp config/config.usb ${STAGE}/config
        fi
        cp -r config/config.usb.inc ${STAGE}/config.inc
    fi

    echo "==> Copying in scripts/"
    cp -r scripts ${STAGE}/scripts

    echo "==> Copying in zoneinit/"
    cp -r zoneinit ${STAGE}/zoneinit

    echo "==> Copying in zones/"
    cp -r zones ${STAGE}/zones
}

function copy_pkgsrc
{
    if [[ ${HAVE_INTERNET} == "true" ]]; then
        (cd ${ROOT}/cache && rm -f md5sums.txt && curl --progress-bar -O ${PKGSRC_ROOT}/md5sums.txt)
    elif [[ ! -f ${ROOT}/cache/md5sums.txt ]]; then
        fatal "Don't have cached md5sums.txt file, can't build. You need to find some Internet."
    fi
    pkgs=$(cat ${ROOT}/zones/*/pkgsrc | xargs -n1 | sort | uniq | sed -e "s/$/.tgz/")
    for pkgfile in $pkgs; do
        MD5=$(grep " ${pkgfile}" ${ROOT}/cache/md5sums.txt | cut -d' ' -f1)
        if [[ -z ${MD5} ]]; then
            fatal "Unable to find md5sum for ${pkgfile}, must be fixed before we can continue."
        fi
        [[ -f ${ROOT}/cache/${pkgfile} ]] && ACTUAL_MD5=$(${MD5CMD} ${ROOT}/cache/${pkgfile} | cut -d' ' -f1)
        if [[ ! -f ${ROOT}/cache/${pkgfile} ]] || [[ -z ${ACTUAL_MD5} ]] || [[ ${MD5} != ${ACTUAL_MD5} ]]; then
            echo "==> Downloading ${pkgfile}"
            # if this exists, it's corrupt
            rm -f ${ROOT}/cache/${pkgfile}
            if [[ ${HAVE_INTERNET} == "true" ]]; then
                (cd ${ROOT}/cache && curl --progress-bar \
                    -k -fO ${PKGSRC_ROOT}/${pkgfile}) || \
                    fatal "could not download ${PKGSRC_ROOT}/${pkgfile}"
            else
                fatal "Need Internet to download ${pkgfile}"
            fi
        else
            echo "==> Not downloading ${pkgfile} as existing file matches MD5"
        fi
    done

    echo "==> Creating pkgsrc.tar"
    (cd ${ROOT}/cache && tar -cvf ${STAGE}/data/pkgsrc.tar ${pkgs})
}

function valid_archive
{
    filename=$1
    if [[ -f ${filename} ]] && tar -tf ${filename} > /dev/null; then
        return 0
    else
        return 1
    fi
}

function copy_platform
{
    valid_platform="false"
    if [ -z $PLATFORM_FILE ]; then
        if [[ ${HAVE_INTERNET} == "true" ]]; then
            latest_image=$(curl -k -sS ${PLATFORM_URL}/ \
                | grep "href=\"platform" | cut -d'"' -f2 | sort | tail -n 1)

            if [[ ! -f "${ROOT}/cache/${latest_image}" ]]; then
                echo "==> Downloading ${latest_image}"
                (cd ${ROOT}/cache && \
                  curl --progress-bar -k -O ${PLATFORM_URL}/${latest_image})
            fi
        else
            latest_image=$(cd ${ROOT}/cache && ls platform-*.tgz | head)
            if [[ -z ${latest_image} ]]; then
                fatal "Unable to find a platform image and we have no Internet."
            fi
        fi

        image=${ROOT}/cache/${latest_image}
        if [[ -f ${image} ]] && ! valid_archive ${image}; then
            echo "Removing corrupt ${image}"
            rm -f ${image}
            image=
            # unset image and try again
            copy_platform
        fi
    else
        image=${PLATFORM_FILE}
        echo "==> Using ${image} as platform image"
        if ! valid_archive "${image}"; then
            fatal "Refusing to use corrupt platform ${image}"
        fi
    fi

    echo "==> Unpacking `basename ${image}`"
    (cd ${STAGE}/ && tar -zxf ${image} && mv platform-* platform)
    if [[ -f ${STAGE}/platform/root.password ]]; then
        (cd ${STAGE}/ && mkdir -p private && mv -f platform/root.password private/)
    fi
    LIVEIMG_VERSION=`basename ${image} | sed -e "s/platform-\(.*\)\.tgz/\1/"`
}

function copy_agents
{
    # Grab the latest agent ur-script too
    if [[ ${HAVE_INTERNET} == "true" ]]; then
        latest_agents=$(curl -k -sS ${MASTER_PLATFORM_URL}/ur-scripts/ \
            | grep "href=\"agents" | cut -d'"' -f2 | sort | tail -n 1)
        if [ ! -f "${ROOT}/cache/${latest_agents}" ]; then
            echo "==> Downloading ${latest_agents}"
            (cd ${ROOT}/cache && curl --progress-bar -k -O ${MASTER_PLATFORM_URL}/ur-scripts/${latest_agents})
        fi
    else
        latest_agents=$(cd ${ROOT}/cache && ls agents-*.sh | head)
        if [[ -z ${latest_agents} ]]; then
            fatal "Unable to find agents and we have no Internet."
        fi
    fi
    mkdir -p ${STAGE}/ur-scripts
    cp ${ROOT}/cache/${latest_agents} ${STAGE}/ur-scripts/${latest_agents}
}

function copy_datasets
{
    datasets=( bare-1.2.8 protemplate-2.5.2 nodejs-0.4.0 )
    for dataset in ${datasets[@]}
    do
        dataset_file="${dataset}.zfs.bz2"
        if ! bzip2 -t ${ROOT}/cache/${dataset_file}; then
            echo "==> Corrupt ${dataset_file}, deleting..."
            rm -f ${ROOT}/cache/${dataset_file}
        fi
        basename=$(echo ${dataset_file} | cut -d'-' -f1)

        if [[ ! -f ${ROOT}/cache/${dataset_file} ]]; then
            if [[ ${HAVE_INTERNET} == "true" ]]; then
                echo "==> Downloading ${dataset_file}"
                (cd ${ROOT}/cache && curl --progress-bar -k -O ${ASSETS_ROOT}/${dataset_file})
            else
                fatal "Don't have Internet, and don't have valid ${dataset_file}. Can't build."
            fi
        fi

        if ! bzip2 -t ${ROOT}/cache/${dataset_file}; then
            rm -f ${ROOT}/cache/${dataset_file}
            fatal "Corrupt ${dataset_file}, deleted! Try build again."
        fi

        echo "==> Copying ${basename}.zfs.bz2"
        cp ${ROOT}/cache/${dataset_file} ${STAGE}/${basename}.zfs.bz2
    done
}

function copy_zones
{
    for zone in $(ls ${STAGE}/zones); do
        fsuri=${STAGE}/zones/${zone}/fs.uri

        if [ ! -f $fsuri ]; then
            continue
        fi

        #
        # We allow the fs.uri file to be overridden with a [zone]_FS variable
        # (e.g., "RABBITMQ_FS"), which must contain a bzip2'd tar file.
        #
        local override=$(echo $zone | tr '[:lower:]' '[:upper:]')_FS

        if [[ -n "${!override}" ]]; then
            file=${!override}

            if [[ ! -f ${file} ]]; then
                fatal "expected a file for $override"
            fi

            if ( ! file ${file} | grep bzip2 > /dev/null ); then
                fatal "expected a bzip2'd tar file for $override"
            fi

            mkdir -p ${STAGE}/zones/${zone}
            echo "==> Using \$${override} (${file}) for ${zone} zone"
            cp ${file} ${STAGE}/zones/${zone}/fs.tar.bz2
            continue
        fi

        #
        # If we have an fs.uri file, it should be a URI indicating a bzip2'd tar
        # file; check that the suffix is either ".tbz2" or ".tar.bz2".
        #
        uri=`cat $fsuri`
        suffix=${uri##*.}

        if [ "$suffix" != "tbz2" ]; then
            prefix=${uri%.*}
            if [ $suffix != "bz2" ] || [ ${prefix##*.} != "tar" ]; then
                fatal "$zone: illegal fs.uri: $uri (expected bzip2\'d tarball)"
            fi
        fi

        #
        # If the path has no subdirectory components, then we'll fetch the
        # file from ${ASSETS_ROOT}.
        #
        if [ ${uri%%/*} == $uri ]; then
            uri=${ASSETS_ROOT}/liveimg/${uri}
        fi

        file=${uri##*/}

        if ! bzip2 -t ${ROOT}/cache/${file}; then
            echo "Corrupt ${file}, deleting..."
            rm -f ${ROOT}/cache/${file}
        fi

        if [[ ${HAVE_INTERNET} == "true" ]]; then
            echo "==> Updating ${file}"
            CURL_OPTS=
            [[ -f ${ROOT}/cache/${file} ]] && CURL_OPTS="-z ${ROOT}/cache/${file}"
            (cd ${ROOT}/cache && curl --progress-bar -k ${CURL_OPTS} -fO $uri) || \
                fatal "could not download $uri for $zone"
        elif [[ ! -f ${ROOT}/cache/${file} ]]; then
            fatal "Don't have Internet and don't have ${file}. Can't build."
        fi

        mkdir -p ${STAGE}/zones/${zone}
        cp ${ROOT}/cache/${file} ${STAGE}/zones/${zone}/fs.tar.bz2
    done

    for zone in $(ls ${STAGE}/zones); do
        if [ -x ${STAGE}/zones/${zone}/fs.populate ] && \
          [ -d ${STAGE}/zones/${zone}/fs.root ]; then
            # do in /tmp because only root can write in mnt
            mkdir -p /tmp/fs.${zone}.$$
            cp -pPR ${STAGE}/zones/${zone}/fs.populate ${STAGE}/zones/${zone}/fs.root /tmp/fs.${zone}.$$
            rm -rf ${STAGE}/zones/${zone}/fs.{populate,root}
            (cd /tmp/fs.${zone}.$$/fs.root && ../fs.populate && tar -jcvf ${STAGE}/zones/${zone}/fs.tar.bz2 ./)
        fi

        if [[ "${IMG_TYPE}" == "coal" ]]; then
          echo "IMG_TYPE=coal" >> ${STAGE}/zones/${zone}/zoneconfig
        fi
    done
}

function copy_devtools
{
    if [[ "${IMG_TYPE}" == "coal" ]]; then
        echo "==> Copying in devtools"
        cp -r ${ROOT}/devtools ${STAGE}/devtools
    fi
}

function copy_to_mount
{
    (cd ${STAGE} && tar ${TAR_ROOT} -cf - ./) | (cd ${MNT_DIR} && ${SUCMD} tar -xvf -)
}

# Main()

test_rootperms
create_directories
copy_base
copy_pkgsrc
copy_platform
copy_agents
copy_datasets
copy_zones
copy_devtools
unpack_image
add_manifests
mount_image
trap 'cleanup' EXIT
copy_to_mount
cleanup
create_output

if [ ${ERROR} -ne 0 ]; then
    fatal "==> SOMETHING WENT WRONG! ERROR: ${ERROR}"
fi

echo "==> DONE"

exit 0
