#!/bin/bash
#
# Copyright (c) 2012 Joyent Inc., All rights reserved.
#
#
# This tool is for reflashing an existing headnode with a new tar image.
#
# WARNING: This is a very dangerous tool! Do not point it at a host containing
# any data you want to keep!
#
#
# You can use:
#
# ./bin/reflash latest <host> [<identityfile>]
#
#    To install the latest master version from your build.spec.* bits-url
#
# ./bin/reflash release-XXXXX <host> [<identityfile>]
#
#    To install the latest release-XXXXX version from your build.spec.* bits-url
#
# ./bin/reflash boot-master-20120530T021716Z-gaba5e72.tgz <host> [<identityfile>]
#
#    To install a specific tar image you created with './bin/build-image tar'
#
# ./bin/reflash https://foo.host.com/path/to/whatever.tgz <host> [<identityfile>]
#
#    To install an image from a remote URL
#

FORCE_65=0

if [[ -n "$TRACE" ]]; then
    export PS4='[\D{%FT%TZ}] ${BASH_SOURCE}:${LINENO}: ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
    set -o xtrace
fi
set -o errexit
#set -o pipefail


ROOT=$(cd $(dirname $0)/../; pwd)

usage()
{
    cat <<EOF
Usage: $0 <filename|URL> <hostname>
EOF
    exit 1
}

if [[ $1 == "-F" ]]; then
    LIVE_DANGEROUSLY=1
    shift
fi
if [[ $1 == "-?" || $1 == "-h" ]]; then
    usage
fi
if [[ $1 == "-6" ]]; then
    FORCE_65=1
    shift
fi

filename=$1
hostname=$2
identityfile=$3
bits_url=

SSH_OPTS=
if [[ -f "$identityfile" ]]; then
  SSH_OPTS="-i $identityfile"
fi

MD5_SUM=
if [[ $(uname -s) == "SunOS" ]]; then
    MD5_CMD="/usr/bin/sum -x md5"
elif [[ $(uname -s) == "Darwin" ]]; then
    MD5_CMD="md5 -q"
else
    echo "Unsupported platform $(uname -s)" >&2
    exit 2
fi

get_bits_url()
{
    if [[ -n ${bits_url} ]]; then
        echo ${bits_url}
        return 0
    fi

    bits_url="https://stuff.smartdatacenter.org/"

    if [[ -f "${ROOT}/build.spec" && -f "${ROOT}/build.spec.local" ]]; then
        MERGED_SPEC=$(${ROOT}/bin/json-merge ${ROOT}/build.spec \
        ${ROOT}/build.spec.local)
    elif [[ -f "${ROOT}/build.spec" ]]; then
        MERGED_SPEC=$(cat ${ROOT}/build.spec)
    elif [[ -f "${ROOT}/build.spec.local" ]]; then
        MERGED_SPEC=$(cat ${ROOT}/build.spec.local)
    fi

    spec_bits_url=$(echo ${MERGED_SPEC} | ${ROOT}/bin/json "bits-url")
    if [[ -n ${spec_bits_url} ]]; then
        bits_url=${spec_bits_url}
    fi

    if [[ ${bits_url:0:23} == "https://stuff.joyent.us" ]]; then
        echo "Adding auth to bits url from '~/.sdcbuild.json'." >&2
        if [[ ! -f "${HOME}/.sdcbuild.json" ]]; then
            echo "error: '~/.sdcbuild.json' does not exist" >&2
            exit 1
        fi
        username=$(cat ~/.sdcbuild.json | ${ROOT}/bin/json username)
        password=$(cat ~/.sdcbuild.json | ${ROOT}/bin/json password)
        bits_url=$(echo ${bits_url} | sed -e "s/\/\//\/\/${username}:${password}@/g")
    fi

    echo ${bits_url}
}

get_latest()
{
    release=$1
    bits_url=$(get_bits_url)

    if [[ $(echo ${release} | tr -d [0-9]) == "release-" ]]; then
        file=$(curl -f -s -k \
            ${bits_url}/sdc/${release}-latest/usbheadnode/ \
            | grep "href" | cut -d '"' -f2 | grep "^boot-")

        if [[ -n ${file} ]]; then
            echo "${bits_url}/sdc/${release}-latest/usbheadnode/${file}"
        fi
    else
        file=$(curl -f -sS -k \
            ${bits_url}/usbheadnodetar/master-latest/usbheadnode/ \
            | grep "href" | cut -d '"' -f2 | grep "^boot-")

        if [[ -n ${file} ]]; then
            echo "${bits_url}/usbheadnodetar/master-latest/usbheadnode/${file}"
        fi
    fi
}

get_md5()
{
    release=$1
    file=$2
    bits_url=$(get_bits_url)

    if [[ $(echo ${release} | tr -d [0-9]) == "release-" ]]; then
        md5=$(curl -f -s -k ${bits_url}/sdc/${release}-latest/md5sums.txt \
            | grep "${file}" | cut -d ' ' -f1)

        if [[ -n ${md5} ]]; then
            echo "${md5}"
        fi
    else
        md5=$(curl -f -sS -k ${bits_url}/usbheadnode/master-latest/md5sums.txt \
            | grep "${file}" | cut -d ' ' -f1)

        if [[ -n ${md5} ]]; then
            echo "${md5}"
        fi
    fi
}

if [[ -z ${filename} || -z ${hostname} || -n $4 ]]; then
    usage
fi

URL=
FILENAME=
if [[ ${filename} == "latest" ]]; then
    echo "Finding latest usbheadnode build..."
    URL=$(get_latest)
    if [[ -z ${URL} ]]; then
        echo "Failed to find latest from ${URL}!" >&2
        exit 1
    fi
    FILENAME=$(basename ${URL})
    MD5_SUM=$(get_md5 "latest" "${FILENAME}")
    echo "Latest is ${URL}..."
elif [[ $(echo ${filename} | tr -d [0-9]) == "release-" ]]; then
    echo "Finding latest ${filename} usbheadnode build..."
    URL=$(get_latest ${filename})
    if [[ -z ${URL} ]]; then
        echo "Failed to find latest ${filename} from ${URL}!" >&2
        exit 1
    fi
    FILENAME=$(basename ${URL})
    MD5_SUM=$(get_md5 "${filename}" "${FILENAME}")
    echo "Latest ${filename} is ${URL}..."
elif [[ "${filename:0:4}" == "http" ]]; then
    URL=${filename}
    echo "Using URL ${URL}..."
    FILENAME=$(basename ${URL})
elif [[ ! -f ${filename} ]]; then
    usage
else
    echo "Attempting upload..."
    scp ${filename} root@${hostname}:/var/tmp
    FILENAME=$(basename ${filename})
    MD5_SUM=$(${MD5_CMD} ${filename} | cut -d ' ' -f1)
fi

if [[ -z ${LIVE_DANGEROUSLY} ]]; then
cat <<EOF

 *** WARNING ***

This is about to attempt flash the machine '${hostname}' without any further
confirmation if this is not what you want to do:

 PRESS CTRL-C NOW!

All data on the specified machine will be destroyed. Including potential
customer data!

 *** WARNING ***

EOF

for i in {9..1}; do
    printf "Starting flash in %d seconds...   \r" ${i}
    sleep 1
done

echo "Continuing!                                "
fi

set +o errexit

# if we're flashing with 65 attempt to create a config if we have answers.json
if [[ ${FILENAME} =~ "release-20110901" || ${FORCE_65} == 1 ]]; then
echo "This looks like 6.5. Attempting to create config."
ssh $SSH_OPTS -T root@${hostname} <<EOF65
if [[ -n "${TRACE}" ]]; then
    set -o xtrace
fi

rm -f /var/tmp/config.flashing

/usbkey/scripts/mount-usb.sh || /bin/true
if [[ ! -f /mnt/usbkey/private/answers.json ]]; then
    echo "No answers.json, not creating config."
    exit 0
fi

#
# Get the max. IP addr for the given field, based in the netmask.
# That is, if netmask is 255, then its just the input field, otherwise its
# the host portion of the netmask (e.g. netmask 224 -> 31).
# Param 1 is the field and param 2 the mask for that field.
#
max_fld()
{
        comp=\$((255 & ~\$2))
        fmax=\$((\${comp} | \$1))
}

#
# Converts an IP and netmask to a network
# For example: 10.99.99.7 + 255.255.255.0 -> 10.99.99.0
# Each field is in the net_a, net_b, net_c and net_d variables.
# Also, host_addr stores the address of the host w/o the network number (e.g.
# 7 in the 10.99.99.7 example above).  Also, max_host stores the max. host
# number (e.g. 10.99.99.254 in the example above).
#
ip_netmask_to_network()
{
        IP=\$1
        NETMASK=\$2

        OLDIFS=\$IFS
        IFS=.
        set -- \$IP
        net_a=\$1
        net_b=\$2
        net_c=\$3
        net_d=\$4
        addr_d=\$net_d

        set -- \$NETMASK

        # Calculate the maximum host address
        max_fld "\$net_a" "\$1"
        max_a=\$fmax
        max_fld "\$net_b" "\$2"
        max_b=\$fmax
        max_fld "\$net_c" "\$3"
        max_c=\$fmax
        max_fld "\$net_d" "\$4"
        max_d=\$(expr \$fmax - 1)
        max_host="\$max_a.\$max_b.\$max_c.\$max_d"

        net_a=\$((\$net_a & \$1))
        net_b=\$((\$net_b & \$2))
        net_c=\$((\$net_c & \$3))
        net_d=\$((\$net_d & \$4))

        host_addr=\$((\$addr_d & ~\$4))
        IFS=\$OLDIFS
}


# Sets two variables, use_lo and use_hi, which are the usable IP addrs for the
# largest block of available host addresses on the subnet, based on the two
# addrs the user has chosen for the GW and External Host IP.
# We look at the three ranges (upper, middle, lower) defined by the two addrs.
calc_ext_default_range()
{
        a1=\$1
        a2=\$2

        if [ \$a1 -lt \$a2 ]; then
                lo=\$a1
                hi=\$a2
        else
                lo=\$a2
                hi=\$a1
        fi

        u_start=\`expr \$hi + 1\`
        m_start=\`expr \$lo + 1\`
        l_start=1

        u_max=\$max_d
        m_max=\`expr \$hi - 1\`
        l_max=\`expr \$lo - 1\`

        up_range=\`expr \$max_d - \$hi\`
        mid_range=\`expr \$hi - \$lo\`
        lo_range=\`expr \$lo - 2\`
        [ \$lo_range -lt 1 ] && lo_range=0

        if [ \$up_range -gt \$mid_range ]; then
                use_lo=\$u_start
                use_hi=\$u_max
                range=\$up_range
        else
                use_lo=\$m_start
                use_hi=\$m_max
                range=\$mid_range
        fi

        if [ \$range -lt \$lo_range ]; then
                use_lo=\$l_start
                use_hi=\$l_max
        fi
}


company_name=\$(json datacenter_company_name < /mnt/usbkey/private/answers.json)
[[ -z \${company_name} ]] && company_name="Joyent"
datacenter_name=\$(json datacenter_name < /mnt/usbkey/private/answers.json)
[[ -z \${datacenter_name} ]] && datacenter_name="dc65"
datacenter_location=\$(json datacenter_location < /mnt/usbkey/private/answers.json)
[[ -z \${datacenter_location} ]] && datacenter_location="the cloud"
datacenter_headnode_id=\$(json datacenter_headnode_id < /mnt/usbkey/private/answers.json)
[[ -z \${datacenter_headnode_id} ]] && datacenter_headnode_id=0
[[ \${datacenter_headnode_id} == "<default>" ]] && datacenter_headnode_id=0
mail_to=\$(json mail_to < /mnt/usbkey/private/answers.json)
[[ -z \${mail_to} || \${mail_to} == "<default>" ]] && mail_to="devs@joyent.com"
mail_from=\$(json mail_from < /mnt/usbkey/private/answers.json)
[[ -z \${mail_from} || \${mail_from} == "<default>" ]] && mail_from="devs@joyent.com"
admin_nic=\$(json admin_nic < /mnt/usbkey/private/answers.json)
admin_ip=\$(json admin_ip < /mnt/usbkey/private/answers.json)
admin_gateway=\$(json admin_gateway < /mnt/usbkey/private/answers.json)
[[ -z \${admin_gateway} || \${admin_gateway} == "none" ]] \
    && admin_gateway=\${admin_ip}
admin_netmask=\$(json admin_netmask < /mnt/usbkey/private/answers.json)
admin_network=\$(json admin_network < /mnt/usbkey/private/answers.json)
if [[ -z \${admin_network} ]]; then
    ip_netmask_to_network "\${admin_ip}" "\${admin_netmask}"
    admin_network="\${net_a}.\${net_b}.\${net_c}.\${net_d}"
fi
admin_provisionable_start=\$(json admin_provisionable_start < /mnt/usbkey/private/answers.json)
if [[ \${admin_provisionable_start} == "<default>" ]]; then

    ip_netmask_to_network "\${admin_ip}" "\${admin_netmask}"

    next_addr=\$(expr \$host_addr + 1)
    admin_provisionable_start="\$net_a.\$net_b.\$net_c.\$next_addr"
fi

if [[ -z \${admin_nic} || -z \${admin_ip} || -z \${admin_netmask} ]]; then
    echo "ERROR: admin_nic, admin_ip and admin_netmask must all exist in answers.json"
    exit 1
fi

external_nic=\$(json external_nic < /mnt/usbkey/private/answers.json)
external_ip=\$(json external_ip < /mnt/usbkey/private/answers.json)
external_netmask=\$(json external_netmask < /mnt/usbkey/private/answers.json)
external_gateway=\$(json external_gateway < /mnt/usbkey/private/answers.json)
external_network=\$(json external_network < /mnt/usbkey/private/answers.json)
if [[ -z \${external_network} ]]; then
    ip_netmask_to_network "\${external_ip}" "\${external_netmask}"
    external_network="\${net_a}.\${net_b}.\${net_c}.\${net_d}"
fi
external_vlan_id=\$(json external_vlan_id < /mnt/usbkey/private/answers.json)
[[ -z \${external_vlan_id} || \${external_vlan_id} == "<default>" ]] && external_vlan_id=0
external_provisionable_start=\$(json external_provisionable_start < /mnt/usbkey/private/answers.json)
external_provisionable_end=\$(json external_provisionable_end < /mnt/usbkey/private/answers.json)
headnode_default_gateway=\$(json headnode_default_gateway < /mnt/usbkey/private/answers.json)
[[ -z \${headnode_default_gateway} || \${headnode_default_gateway} == "<default>" ]] \
    && headnode_default_gateway="\${external_gateway}"

if [[ -z \${external_nic} || -z \${external_ip} || -z \${external_netmask} || -z \${external_gateway} ]]; then
    echo "ERROR: external_nic, external_ip, external_netmask and external_gateway must all exist in answers.json"
    exit 1
fi

if [[ -z \${external_provisionable_start} || -z \${external_provisionable_end} ]]; then
    echo "ERROR: external_provisionable_start and external_provisionable_end must both be defined in answers.json"
    exit 1
fi

if [[ "\${external_provisionable_start}" == "<default>" || "\${external_provisionable_end}" == "<default>" ]]; then

    ip_netmask_to_network "\${external_ip}" "\${external_netmask}"
    ip_host_addr=\${host_addr}
    ip_netmask_to_network "\${external_gateway}" "\${external_netmask}"

    # Get use_lo and use_hi values for defaults
    calc_ext_default_range \${host_addr} \${ip_host_addr}

    next_addr=\$(expr \$host_addr + 5)
    if [[ \${external_provisionable_start} == "<default>" ]]; then
        external_provisionable_start="\$net_a.\$net_b.\$net_c.\$next_addr"
    fi
    if [[ \${external_provisionable_end} == "<default>" ]]; then
        external_provisionable_end="\$max_a.\$max_b.\$max_c.\$use_hi"
    fi
fi

dns_resolver1=\$(json dns_resolver1 < /mnt/usbkey/private/answers.json)
[[ -z \${dns_resolver1} || \${dns_resolver1} == "<default>" ]] && dns_resolver1="8.8.8.8"
dns_resolver2=\$(json dns_resolver2 < /mnt/usbkey/private/answers.json)
[[ -z \${dns_resolver2} || \${dns_resolver2} == "<default>" ]] && dns_resolver2="8.8.4.4"
dns_domain=\$(json dns_domain < /mnt/usbkey/private/answers.json)
[[ -z \${dns_domain} || \${dns_domain} == "<default>" ]] && dns_domain="joyent.us"


#
# Calculate admin network IP address for each core zone
#
ip_netmask_to_network "\$admin_provisionable_start" "\$admin_netmask"
next_addr=\$host_addr
assets_admin_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
dhcpd_admin_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
adminui_admin_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
ca_admin_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
capi_admin_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
mapi_admin_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
cloudapi_admin_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
billapi_admin_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
riak_admin_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
rabbitmq_admin_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
dhcp_range_end="\$max_host"

ip_netmask_to_network "\$external_provisionable_start" "\$external_netmask"
next_addr=\$host_addr
adminui_external_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
capi_external_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
portal_external_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
billapi_external_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"
next_addr=\$(expr \$next_addr + 1)
cloudapi_external_ip="\$net_a.\$net_b.\$net_c.\$(expr \$net_d + \$next_addr)"

cat > /var/tmp/config.flashing <<EOF

swap=0.25x
compute_node_swap=0.25x

datacenter_name="\${datacenter_name}"
datacenter_company_name="\${company_name}"
datacenter_location="\${datacenter_location}"
datacenter_headnode_id=\${datacenter_headnode_id}

default_rack_name=RACK1
default_rack_size=30
default_server_role=pro
default_package_sizes="128,256,512,1024"

mail_to="\${mail_to}"
mail_from="\${mail_from}"

admin_nic=\${admin_nic}
admin_ip=\${admin_ip}
admin_netmask=\${admin_netmask}
admin_network=\${admin_network}
admin_gateway=\${admin_gateway}

external_nic=\${external_nic}
external_ip=\${external_ip}
external_network=\${external_network}
external_vlan_id=\${external_vlan_id}
external_provisionable_start=\${external_provisionable_start}
external_provisionable_end=\${external_provisionable_end}
external_netmask=\${external_netmask}
external_gateway=\${external_gateway}

headnode_default_gateway=\${headnode_default_gateway}
compute_node_default_gateway=\${admin_ip}

dns_resolvers=\${dns_resolver1},\${dns_resolver2}
dns_domain=\${dns_domain}

dhcp_range_start=\${admin_provisionable_start}
dhcp_range_end=\${dhcp_range_end}
dhcp_lease_time=86400
dhcp_next_server=\${dhcpd_admin_ip}

initial_script=scripts/headnode.sh

root_shadow='\\\$5\\\$2HOHRnK3\\\$NvLlm.1KQBbB0WjoP7xcIwGnllhzp2HnT.mDO7DpxYA'
admin_shadow='\\\$5\\\$f1mBmj6p\\\$oDDuYhLZzQIAZ5.QAAyr37lTN.K5FtLECvngsTLhWh5'

ntp_hosts=pool.ntp.org
compute_node_ntp_hosts=\${admin_ip}

adminui_admin_ip=\${adminui_admin_ip}
adminui_external_ip=\${adminui_external_ip}
adminui_external_vlan=\${external_vlan_id}
adminui_root_pw=joypass123
adminui_admin_pw=joypass123
adminui_help_url=http://sdcdoc.joyent.com/

assets_admin_ip=\${assets_admin_ip}
assets_root_pw=joypass123
assets_admin_pw=joypass123

ca_admin_ip=\${ca_admin_ip}
ca_root_pw=joypass123
ca_admin_pw=joypass123
ca_client_url=http://\${ca_admin_ip}:23181

capi_is_local=true
capi_admin_ip=\${capi_admin_ip}
capi_client_url=http://\${capi_admin_ip}:8080
capi_external_ip=\${capi_external_ip}
capi_external_url=http://\${capi_external_ip}:8080
capi_external_vlan=\${external_vlan_id}
capi_root_pw=joypass123
capi_http_admin_user=admin
capi_http_admin_pw=tot@ls3crit
capi_admin_login=admin
capi_admin_pw=joypass123
capi_admin_email=user@joyent.com
capi_admin_uuid=930896af-bf8c-48d4-885c-6573a94b1853

dhcpd_admin_ip=\${dhcpd_admin_ip}
dhcpd_root_pw=joypass123
dhcpd_admin_pw=joypass123

dnsapi_http_port=8000
dnsapi_http_user=admin
dnsapi_http_pass=joypass123

dsapi_url=https://datasets.joyent.com
dsapi_http_user=honeybadger
dsapi_http_pass=IEatSnakes4Fun

mapi_admin_ip=\${mapi_admin_ip}
mapi_client_url=http://\${mapi_admin_ip}:80
mapi_root_pw=joypass123
mapi_admin_pw=joypass123
mapi_mac_prefix=90b8d0
mapi_http_port=8080
mapi_http_admin_user=admin
mapi_http_admin_pw=tot@ls3crit
mapi_datasets="smartos,nodejs"
mapi_heartbeater_pool_instances=3

portal_external_ip=\${portal_external_ip}
portal_external_vlan=\${external_vlan_id}
portal_root_pw=joypass123
portal_admin_pw=joypass123
portal_external_url=https://\${portal_external_ip}

cloudapi_admin_ip=\${cloudapi_admin_ip}
cloudapi_external_ip=\${cloudapi_external_ip}
cloudapi_external_vlan=\${external_vlan_id}
cloudapi_root_pw=joypass123
cloudapi_admin_pw=joypass123
cloudapi_external_url=https://\${cloudapi_external_ip}

billapi_admin_ip=\${billapi_admin_ip}
billapi_external_ip=\${billapi_external_ip}
billapi_external_vlan=\${external_vlan_id}
billapi_root_pw=joypass123
billapi_admin_pw=joypass123
billapi_external_url=https://\${billapi_external_ip}
billapi_http_admin_user=admin
billapi_http_admin_pw=joypass123

riak_admin_ip=\${riak_admin_ip}
riak_root_pw=joypass123
riak_admin_pw=joypass123

rabbitmq_admin_ip=\${rabbitmq_admin_ip}
rabbitmq_root_pw=joypass123
rabbitmq_admin_pw=joypass123
rabbitmq=guest:guest:\${rabbitmq_admin_ip}:5672

phonehome_automatic=true

EOF

EOF65
fi

ssh $SSH_OPTS -T root@${hostname} <<EOF
set -o errexit
if [[ -n "${TRACE}" ]]; then
    set -o xtrace
fi

# Turn on DNS since we might need it
echo "Enabling DNS..."
sed -i "" "s/^hosts:.*/hosts:      files mdns dns/" /etc/nsswitch.conf

# XXX this is a hack to figure out if we're in the bh1 lab (assume we are if
# the IP is 10.2.X.X) so that we can switch the stuff url to an IP because the
# URL doesn't work in the lab.
URL="${URL}"
if [[ \$(sysinfo -p | grep "^Network_Interface.*IPv4_Address=" \
    | cut -d "'" -f2 | grep 10\.2\. | wc -l | tr -d ' ') -gt 0 ]]; then

    # assume we're in the lab
    echo "Running in BH1, fixing URL..."
    URL=\$(echo "\${URL}" | sed -e "s/stuff.joyent.us/10.2.0.190/")
fi

# Make sure we've got our file
if [[ ! -f "/var/tmp/${FILENAME}" ]]; then
    echo "Downloading \${URL}"
    curl -f -k -o /var/tmp/${FILENAME} \${URL}
    if [[ ! -f "/var/tmp/${FILENAME}" ]]; then
        echo "FAILED to download image." >&2
        exit 1
    fi
fi

# Check MD5 of image
if [[ -n "${MD5_SUM}" ]]; then
    MD5=\$(/usr/bin/sum -x md5 /var/tmp/${FILENAME} | cut -d ' ' -f1)
    if [[ \${MD5} != "${MD5_SUM}" ]]; then
        echo "MD5 does not match." >&2
        exit 1
    fi
fi

# let everyone who might be logged in know
echo 'This system is being reimaged! ALL YOUR DATA ARE BELONG TO /dev/null.' \
    | wall

# mount the usb key
echo "Mounting USB key..."
/usbkey/scripts/mount-usb.sh

# Move these first so we only restore if they existed to start with
# keep them though in case there is a reflash failure.
timestamp=\$(TZ=UTC date "+%Y%m%dT%H%M%SZ")
mv /var/tmp/root.authorized_keys.flashing /var/tmp/root.authorized_keys.\${timestamp} \
    || /bin/true
mv /var/tmp/answers.flashing /var/tmp/answers.\${timestamp} || /bin/true
mv /var/tmp/devtools.flashing /var/tmp/devtools.\${timestamp} || /bin/true

# Keep the answers.json if it exists
if [[ -f /mnt/usbkey/private/answers.json ]]; then
    echo "Saving answers.json..."
    cp /mnt/usbkey/private/answers.json /var/tmp/answers.flashing
fi

# Also keep root.authorized_keys if it exists
if [[ -f /mnt/usbkey/config.inc/root.authorized_keys ]]; then
    echo "Saving root.authorized_keys..."
    cp /mnt/usbkey/config.inc/root.authorized_keys \
        /var/tmp/root.authorized_keys.flashing
fi

# backup devtools
if [[ -d /mnt/usbkey/devtools ]]; then
     cp -RP /mnt/usbkey/devtools /var/tmp/devtools.flashing
fi

# Remove everything!
echo "Wiping /mnt/usbkey..."
rm -rf /mnt/usbkey/*

# copy devtools back (we'll unpack new ones over old ones but keep custom ones)
if [[ -d /var/tmp/devtools.flashing ]]; then
    cp -RP /var/tmp/devtools.flashing /mnt/usbkey/devtools
fi

# Unpack the image
# XXX there doesn't appear to be a way to disable these permission warnings on
# SmartOS tar. They occur because we're writing to pcfs which doesn't support
# the permissions from the tarball.
echo "Unpacking new image..."
(cd /mnt/usbkey && tar -zxf /var/tmp/${FILENAME}) 2>&1 \
     | sed -e "s/tar: warning - file permissions have changed for //" \
     | sed -e "s/ (are 0100.*, should be .*)$//"

# Restore the answers.json if we had one.
if [[ -f /var/tmp/answers.flashing ]]; then
    echo "Restoring answers.json..."
    mkdir -p /mnt/usbkey/private
    cp /var/tmp/answers.flashing /mnt/usbkey/private/answers.json
    rm -f /var/tmp/answers.flashing
fi

# Copy over config if we created one
if [[ ( "${FILENAME}" =~ "release-20110901" || ${FORCE_65} == 1 ) && -f /var/tmp/config.flashing ]]; then
    echo "Copying in created config..."
    cp /var/tmp/config.flashing /mnt/usbkey/config
    rm -f /var/tmp/config.flashing
fi

# Restore root.authorized_keys if we had one
if [[ -f /var/tmp/root.authorized_keys.flashing ]]; then
    echo "Restoring root.authorized_keys..."
    cp /var/tmp/root.authorized_keys.flashing \
        /mnt/usbkey/config.inc/root.authorized_keys
    rm -f /var/tmp/root.authorized_keys.flashing
fi

# Ensure we've got a platform + grub
if [[ ! -f /mnt/usbkey/boot/grub/menu.lst ]]; then
    echo "Missing grub menu.lst, bailing" >&2
    exit 1
fi
if [[ -z \$(find /mnt/usbkey/os/ -name "boot_archive") ]]; then
    echo "Missing boot_archive, bailing" >&2
    exit 1
fi

# This is what sdc-factoryreset does
echo "Performing factoryreset..."
SYS_ZPOOL=\$(svcprop -p config/zpool smartdc/init)
[[ -n \${SYS_ZPOOL} ]] || SYS_ZPOOL=zones
if zfs list zones/var > /dev/null; then
    zfs set smartdc:factoryreset=yes \${SYS_ZPOOL}/var
fi

if [[ "${FILENAME}" =~ "release-20110901" || ${FORCE_65} == 1 ]]; then
    echo "WARNING: Manually destroying zpool since target is 6.5"

    # wipe the zpool out manually since we can't delete it on a 6.5 platform
    # if it was created on a 7 platform.
    for disk in \$(disklist -s); do
        device=\${disk%%=*}
        size=\${disk##*=}

        if zpool status zones | grep " \${device} " > /dev/null; then
            echo "WARNING: Wiping out zpool info on \${device}"
            # wipe out first MiB and last MiB.
            set +o errexit
            dd if=/dev/zero of=/dev/rdsk/\${device} bs=\$((1024 * 1024)) count=1
            dd if=/dev/zero of=/dev/rdsk/\${device} bs=\$((1024 * 1024)) \
                seek=\$(((\${size} / (1024 * 1024)) - 1))
            set -o errexit
        fi
    done
fi

# Good to go!
echo "Rebooting..."
(sleep 1; reboot -q)&

exit 0
EOF
retval=$?
set -o errexit

if [[ $retval == 0 ]]; then
    echo "Success! '${hostname}' should be running through setup shortly!"
    exit 0
else
    echo "Uh-oh! Something failed (retval=$retval), good luck fixing it!" >&2
    exit 2
fi
