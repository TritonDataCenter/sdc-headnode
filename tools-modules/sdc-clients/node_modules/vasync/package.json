{
  "name": "vasync",
  "version": "1.3.3",
  "description": "utilities for observable asynchronous control flow",
  "main": "./lib/vasync.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/davepacheco/node-vasync.git"
  },
  "dependencies": {
    "jsprim": "0.3.0",
    "verror": "1.1.0"
  },
  "engines": [
    "node >=0.6.0"
  ],
  "readme": "# vasync: utilities for observable asynchronous control flow\n\nThis module provides facilities for asynchronous control flow.  There are many\nmodules that do this already (notably async.js).  This one's claim to fame is\naided debuggability.\n\n\n## Observability is important\n\nWorking with Node's asynchronous, callback-based model is much easier with a\nhandful of simple control-flow abstractions, like pipelines (which invoke a list\nof asynchronous callbacks sequentially) and parallel pipelines (which invoke a\nlist of asynchronous callbacks in parallel and invoke a top-level callback when\nthe last one completes).  But these structures also introduce new types of\nprogramming errors: failing to invoke the \"advance\" callback can cause the\nprogram to hang, and inadvertently invoking it twice can cause subsequent\noperations to proceed before they should.  Both of these can be really nasty to\ndebug after the fact because there's usually no trace of what happened.  And\nwhile tools like \"pstack\" or \"gdb\" help alleviate analogous problems in threaded\nenvironments, they're useless for Node because what's blocking the program isn't\ngenerally on the stack.\n\nThis module implements abstractions for asynchronous control flow that keep\ntrack of what's going on so that you can figure out what happened when your\nprogram goes wrong.  The \"pipeline\" and \"parallel\" functions here both take a\nlist of asynchronous functions (to be invoked in sequence or parallel,\nrespectively), and both return a status object with several fields:\n\n    operations          array corresponding to the input functions, with\n\n            func            input function\n\n            status          \"pending\", \"ok\", or \"fail\"\n\n            err             returned \"err\" value, if any\n\n            result          returned \"result\" value, if any\n\n    successes           \"result\" field for each of \"operations\" where\n                        \"status\" == \"ok\" (in no particular order)\n\n    ndone               number of input operations that have completed\n\n    nerrors             number of input operations that have failed\n\nAs long as you keep a reference to this returned object, then when your program\ndoes something wrong (e.g., hangs or invokes a second stage before it should\nhave), you have several ways of getting at the status:\n\n* On illumos-based systems, use MDB to [find the status object](http://dtrace.org/blogs/bmc/2012/05/05/debugging-node-js-memory-leaks/)\n  and then [print it out](http://dtrace.org/blogs/dap/2012/01/13/playing-with-nodev8-postmortem-debugging/).\n* Provide an HTTP API (or AMQP, or whatever) that returns these pending status\n  objects as JSON (see [kang](https://github.com/davepacheco/kang)).\n* Incorporate a REPL into your program and print out the status object.\n* Use the Node debugger to print out the status object.\n\nOnce you get the status object using any of these methods, you can see exactly\nwhich functions have completed, what they returned, and which ones are\noutstanding.\n\n## Facilities\n\nThis module implements the following utilities:\n\n* `parallel(args, callback)`: invoke N functions in parallel (and merge the\n  results)\n* `forEachParallel(args, callback)`: invoke the same function on N inputs in parallel\n* `pipeline(args, callback)`: invoke N functions in series (and stop on failure)\n* `barrier([args])`: coordinate multiple concurrent operations\n* `queuev(args)`: fixed-size worker queue\n\n### parallel(args, callback): invoke N functions in parallel and merge the results\n\nThis function takes a list of input functions (specified by the \"funcs\" property\nof \"args\") and runs them all.  These input functions are expected to be\nasynchronous: they get a \"callback\" argument and should invoke it as\ncallback(err, result).  The error and result will be saved and made available to\nthe original caller when all of these functions complete.\n\nAll errors are combined into a single \"err\" parameter to the final callback (see\nbelow).  You can also observe the progress of the operation as it goes by\nexamining the object returned synchronously by this function.\n\nExample usage:\n\n    status = mod_vasync.parallel({\n        'funcs': [\n             function f1 (callback) { mod_fs.stat('/tmp', callback); },\n             function f2 (callback) { mod_fs.stat('/noexist', callback); },\n             function f3 (callback) { mod_fs.stat('/var', callback); }\n        ]\n    }, function (err, results) {\n            console.log('error: %s', err.message);\n            console.log('results: %s', mod_util.inspect(results, null, 3));\n    });\n\n    console.log('status: %s', mod_sys.inspect(status, null, 3));\n\nIn the first tick, this outputs:\n\n    status: { operations: \n       [ { func: [Function: f1], status: 'pending' },\n         { func: [Function: f2], status: 'pending' },\n         { func: [Function: f3], status: 'pending' } ],\n      successes: [],\n      ndone: 0,\n      nerrors: 0 }\n\nshowing that there are three operations pending and none has yet been started.\nWhen the program finishes, it outputs this error:\n\n    error: first of 1 error: ENOENT, no such file or directory '/noexist'\n\nwhich encapsulates all of the intermediate failures.  This model allows you to\nwrite the final callback like you normally would:\n\n    if (err)\n            return (callback(err));\n\nand still propagate useful information to callers that don't deal with multiple\nerrors (i.e. most callers).\n\nThe example also prints out the detailed final status, including all of the\nerrors and return values:\n\n    results: { operations: \n       [ { func: [Function: f1],\n           status: 'ok',\n           err: null,\n           result: \n            { dev: 140247096,\n              ino: 879368309,\n              mode: 17407,\n              nlink: 9,\n              uid: 0,\n              gid: 3,\n              rdev: 0,\n              size: 754,\n              blksize: 4096,\n              blocks: 8,\n              atime: Thu, 12 Apr 2012 23:18:57 GMT,\n              mtime: Tue, 17 Apr 2012 23:56:34 GMT,\n              ctime: Tue, 17 Apr 2012 23:56:34 GMT } },\n         { func: [Function: f2],\n           status: 'fail',\n           err: { [Error: ENOENT, no such file or directory '/noexist'] errno: 34, code: 'ENOENT', path: '/noexist' },\n           result: undefined },\n         { func: [Function: f3],\n           status: 'ok',\n           err: null,\n           result: \n            { dev: 23658528,\n              ino: 5,\n              mode: 16877,\n              nlink: 27,\n              uid: 0,\n              gid: 0,\n              rdev: -1,\n              size: 27,\n              blksize: 2560,\n              blocks: 3,\n              atime: Fri, 09 Sep 2011 14:28:55 GMT,\n              mtime: Wed, 04 Apr 2012 17:51:20 GMT,\n              ctime: Wed, 04 Apr 2012 17:51:20 GMT } } ],\n      successes: \n       [ { dev: 234881026,\n           ino: 24965,\n           mode: 17407,\n           nlink: 8,\n           uid: 0,\n           gid: 0,\n           rdev: 0,\n           size: 272,\n           blksize: 4096,\n           blocks: 0,\n           atime: Tue, 01 May 2012 16:02:24 GMT,\n           mtime: Tue, 01 May 2012 19:10:35 GMT,\n           ctime: Tue, 01 May 2012 19:10:35 GMT },\n         { dev: 234881026,\n           ino: 216,\n           mode: 16877,\n           nlink: 26,\n           uid: 0,\n           gid: 0,\n           rdev: 0,\n           size: 884,\n           blksize: 4096,\n           blocks: 0,\n           atime: Tue, 01 May 2012 16:02:24 GMT,\n           mtime: Fri, 14 Aug 2009 21:23:03 GMT,\n           ctime: Thu, 28 Oct 2010 21:51:39 GMT } ],\n      ndone: 3,\n      nerrors: 1 }\n\nYou can use this if you want to handle all of the errors individually or to get\nat all of the individual return values.\n\nNote that \"successes\" is provided as a convenience and the order of items in\nthat array may not correspond to the order of the inputs.  To consume output in\nan ordered manner, you should iterate over \"operations\" and pick out the result\nfrom each item.\n\n\n### forEachParallel(args, callback): invoke the same function on N inputs in parallel\n\nThis function is exactly like `parallel`, except that the input is specified as\na *single* function (\"func\") and a list of inputs (\"inputs\").  The function is\ninvoked on each input in parallel.\n\nThis example is exactly equivalent to the one above:\n\n    mod_vasync.forEachParallel({\n        'func': mod_fs.stat,\n        'inputs': [ '/var', '/nonexistent', '/tmp' ]\n    }, function (err, results) {\n        console.log('error: %s', err.message);\n        console.log('results: %s', mod_util.inspect(results, null, 3));\n    });\n\n\n### pipeline(args, callback): invoke N functions in series (and stop on failure)\n\nThe arguments for this function are:\n\n* funcs: input functions, to be invoked in series\n* arg: arbitrary argument that will be passed to each function\n\nThe functions are invoked in order as `func(arg, callback)`, where \"arg\" is the\nuser-supplied argument from \"args\" and \"callback\" should be invoked in the usual\nway.  If any function emits an error, the whole pipeline stops.\n\nThe return value and the arguments to the final callback are exactly the same as\nfor `parallel`.  The error object for the final callback is just the error\nreturned by whatever pipeline function failed (if any).\n\nThis example is similar to the one above, except that it runs the steps in\nsequence and stops early because `pipeline` stops on the first error:\n\n    console.log(mod_vasync.pipeline({\n        'funcs': [\n            function f1 (_, callback) { mod_fs.stat('/tmp', callback); },\n            function f2 (_, callback) { mod_fs.stat('/noexist', callback); },\n            function f3 (_, callback) { mod_fs.stat('/var', callback); }\n        ]\n    }, function (err, results) {\n            console.log('error: %s', err.message);\n            console.log('results: %s', mod_util.inspect(results, null, 3));\n    }));\n\nAs a result, the status after the first tick looks like this:\n\n    { operations: \n       [ { func: [Function: f1], status: 'pending' },\n         { func: [Function: f2], status: 'waiting' },\n         { func: [Function: f3], status: 'waiting' } ],\n      successes: [],\n      ndone: 0,\n      nerrors: 0 }\n\n(Note that the second and third stages are now \"waiting\", rather than \"pending\"\nin the `parallel` case.)  The error reported is:\n\n    error: ENOENT, no such file or directory '/noexist'\n\nand the complete result is:\n\n    results: { operations: \n       [ { func: [Function: f1],\n           status: 'ok',\n           err: null,\n           result: \n            { dev: 140247096,\n              ino: 879368309,\n              mode: 17407,\n              nlink: 9,\n              uid: 0,\n              gid: 3,\n              rdev: 0,\n              size: 754,\n              blksize: 4096,\n              blocks: 8,\n              atime: Thu, 12 Apr 2012 23:18:57 GMT,\n              mtime: Tue, 17 Apr 2012 23:56:34 GMT,\n              ctime: Tue, 17 Apr 2012 23:56:34 GMT } },\n         { func: [Function: f2],\n           status: 'fail',\n           err: { [Error: ENOENT, no such file or directory '/noexist'] errno: 34, code: 'ENOENT', path: '/noexist' },\n           result: undefined },\n         { func: [Function: f3], status: 'waiting' } ],\n      successes: \n       [ { dev: 234881026,\n           ino: 24965,\n           mode: 17407,\n           nlink: 8,\n           uid: 0,\n           gid: 0,\n           rdev: 0,\n           size: 272,\n           blksize: 4096,\n           blocks: 0,\n           atime: Tue, 01 May 2012 16:02:24 GMT,\n           mtime: Tue, 01 May 2012 19:10:35 GMT,\n           ctime: Tue, 01 May 2012 19:10:35 GMT } ],\n      ndone: 2,\n      nerrors: 1 }\n\n### barrier([args]): coordinate multiple concurrent operations\n\nReturns a new barrier object.  Like `parallel`, barriers are useful for\ncoordinating several concurrent operations, but instead of specifying a list of\nfunctions to invoke, you just say how many (and optionally which ones) are\noutstanding, and this object emits `'drain'` when they've all completed.  This\nis syntactically lighter-weight, and more flexible.\n\n* Methods:\n\n    * start(name): Indicates that the named operation began.  The name must not\n      match an operation which is already ongoing.\n    * done(name): Indicates that the named operation ended.\n\n\n* Read-only public properties (for debugging):\n\n    * pending: Set of pending operations.  Keys are names passed to \"start\", and\n      values are timestamps when the operation began.\n    * recent: Array of recent completed operations.  Each element is an object\n      with a \"name\", \"start\", and \"done\" field.  By default, 10 operations are\n      remembered.\n\n\n* Options:\n\n    * nrecent: number of recent operations to remember (for debugging)\n\nExample: printing sizes of files in a directory\n\n    var mod_fs = require('fs');\n    var mod_path = require('path');\n    var mod_vasync = require('../lib/vasync');\n\n    var barrier = mod_vasync.barrier();\n\n    barrier.on('drain', function () {\n    \tconsole.log('all files checked');\n    });\n\n    barrier.start('readdir');\n\n    mod_fs.readdir(__dirname, function (err, files) {\n    \tbarrier.done('readdir');\n\n    \tif (err)\n    \t\tthrow (err);\n\n    \tfiles.forEach(function (file) {\n    \t\tbarrier.start('stat ' + file);\n\n    \t\tvar path = mod_path.join(__dirname, file);\n\n    \t\tmod_fs.stat(path, function (err2, stat) {\n    \t\t\tbarrier.done('stat ' + file);\n    \t\t\tconsole.log('%s: %d bytes', file, stat['size']);\n    \t\t});\n    \t});\n    });\n\nThis emits:\n\n    barrier-readdir.js: 602 bytes\n    foreach-parallel.js: 358 bytes\n    barrier-basic.js: 552 bytes\n    nofail.js: 384 bytes\n    pipeline.js: 490 bytes\n    parallel.js: 481 bytes\n    queue-serializer.js: 441 bytes\n    queue-stat.js: 529 bytes\n    all files checked\n\n\n### queue(worker, concurrency): fixed-size worker queue\n### queuev(args)\n\nThis function returns an object that allows up to a fixed number of tasks to be\ndispatched at any given time.  The interface is compatible with that provided\nby the \"async\" Node library, except that the returned object's fields represent\na public interface you can use to introspect what's going on.\n\n* Arguments\n\n    * worker: a function invoked as `worker(task, callback)`, where `task` is a\n      task dispatched to this queue and `callback` should be invoked when the\n      task completes.\n    * concurrency: a positive integer indicating the maximum number of tasks\n      that may be dispatched at any time.  With concurrency = 1, the queue\n      serializes all operations.\n\n\n* Methods\n\n    * push(task, [callback]): add a task (or array of tasks) to the queue, with\n      an optional callback to be invoked when each task completes.  If a list of\n      tasks are added, the callback is invoked for each one.\n    * length(): for compatibility with node-async.\n\n\n* Read-only public properties (for debugging):\n\n    * concurrency: for compatibility with node-async\n    * worker: worker function, as passed into \"queue\"/\"queuev\"\n    * worker\\_name: worker function's \"name\" field\n    * npending: the number of tasks currently being processed\n    * pending: an object (*not* an array) describing the tasks currently being\n      processed\n    * queued: array of tasks currently queued for processing\n\n\n* Hooks (for compatibility with node-async):\n\n    * saturated\n    * empty\n    * drain\n\nIf the tasks are themselves simple objects, then the entire queue may be\nserialized (as via JSON.stringify) for debugging and monitoring tools.  Using\nthe above fields, you can see what this queue is doing (worker\\_name), which\ntasks are queued, which tasks are being processed, and so on.\n\n### Example 1: Stat several files\n\nHere's an example demonstrating the queue:\n\n    var mod_fs = require('fs');\n    var mod_vasync = require('../lib/vasync');\n\n    var queue;\n\n    function doneOne()\n    {\n    \tconsole.log('task completed; queue state:\\n%s\\n',\n    \t    JSON.stringify(queue, null, 4));\n    }\n\n    queue = mod_vasync.queue(mod_fs.stat, 2);\n\n    console.log('initial queue state:\\n%s\\n', JSON.stringify(queue, null, 4));\n\n    queue.push('/tmp/file1', doneOne);\n    queue.push('/tmp/file2', doneOne);\n    queue.push('/tmp/file3', doneOne);\n    queue.push('/tmp/file4', doneOne);\n\n    console.log('all tasks dispatched:\\n%s\\n', JSON.stringify(queue, null, 4));\n\nThe initial queue state looks like this:\n\n    initial queue state: \n    {\n        \"nextid\": 0,\n        \"worker_name\": \"anon\",\n        \"npending\": 0,\n        \"pending\": {},\n        \"queued\": [],\n        \"concurrency\": 2\n    }\n\nAfter four tasks have been pushed, we see that two of them have been dispatched\nand the remaining two are queued up:\n\n    all tasks pushed:\n    {\n        \"nextid\": 4,\n        \"worker_name\": \"anon\",\n        \"npending\": 2,\n        \"pending\": {\n            \"1\": {\n                \"id\": 1,\n                \"task\": \"/tmp/file1\"\n            },\n            \"2\": {\n                \"id\": 2,\n                \"task\": \"/tmp/file2\"\n            }\n        },\n        \"queued\": [\n            {\n                \"id\": 3,\n                \"task\": \"/tmp/file3\"\n            },\n            {\n                \"id\": 4,\n                \"task\": \"/tmp/file4\"\n            }\n        ],\n        \"concurrency\": 2\n    }\n\nAs they complete, we see tasks moving from \"queued\" to \"pending\", and completed\ntasks disappear:\n\n    task completed; queue state:\n    {\n        \"nextid\": 4,\n        \"worker_name\": \"anon\",\n        \"npending\": 1,\n        \"pending\": {\n            \"3\": {\n                \"id\": 3,\n                \"task\": \"/tmp/file3\"\n            }\n        },\n        \"queued\": [\n            {\n                \"id\": 4,\n                \"task\": \"/tmp/file4\"\n            }\n        ],\n        \"concurrency\": 2\n    }\n\nWhen all tasks have completed, the queue state looks like it started:\n\n    task completed; queue state:\n    {\n        \"nextid\": 4,\n        \"worker_name\": \"anon\",\n        \"npending\": 0,\n        \"pending\": {},\n        \"queued\": [],\n        \"concurrency\": 2\n    }\n\n\n### Example 2: A simple serializer\n\nYou can use a queue with concurrency 1 and where the tasks are themselves\nfunctions to ensure that an arbitrary asynchronous function never runs\nconcurrently with another one, no matter what each one does.  Since the tasks\nare the actual functions to be invoked, the worker function just invokes each\none:\n\n    var mod_vasync = require('../lib/vasync');\n\n    var queue = mod_vasync.queue(\n        function (task, callback) { task(callback); }, 1);\n\n    queue.push(function (callback) {\n    \tconsole.log('first task begins');\n    \tsetTimeout(function () {\n    \t\tconsole.log('first task ends');\n    \t\tcallback();\n    \t}, 500);\n    });\n\n    queue.push(function (callback) {\n    \tconsole.log('second task begins');\n    \tprocess.nextTick(function () {\n    \t\tconsole.log('second task ends');\n    \t\tcallback();\n    \t});\n    });\n\nThis example outputs:\n\n    $ node examples/queue-serializer.js \n    first task begins\n    first task ends\n    second task begins\n    second task ends\n",
  "readmeFilename": "README.md",
  "_id": "vasync@1.3.3",
  "_from": "vasync@1.3.3"
}
